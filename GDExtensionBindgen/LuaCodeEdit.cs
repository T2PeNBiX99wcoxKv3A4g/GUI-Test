// ReSharper disable CommentTypo
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable IdentifierTypo
// ReSharper disable UnusedType.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable EventNeverSubscribedTo.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable CheckNamespace
// ReSharper disable StringLiteralTypo
// ReSharper disable MemberHidesStaticFromOuterClass
// This code was automatically generated by GDExtension C# Bindgen

using System;
using Godot;
using Godot.Collections;

namespace GDExtensionBindgen;

public class LuaCodeEdit
{
    // Engine object used for calling engine methods
    protected readonly CodeEdit Object;

    public LuaCodeEdit() : this(NativeName)
    {
    }

    protected LuaCodeEdit(StringName @class) : this(ClassDB.Instantiate(@class))
    {
    }

    protected LuaCodeEdit(Variant variant) : this((CodeEdit)variant)
    {
    }

    protected LuaCodeEdit(CodeEdit @object)
    {
        Object = @object;
    }

    public static implicit operator CodeEdit(LuaCodeEdit self) => self.Object;
    public static implicit operator Variant(LuaCodeEdit self) => self.Object;

    public static explicit operator LuaCodeEdit(Variant variant) => new(variant.AsGodotObject());

    public class PropertyName : CodeEdit.PropertyName
    {
    }

    public class MethodName : CodeEdit.MethodName
    {
    }

    public class SignalName : CodeEdit.SignalName
    {
    }

    private static readonly StringName NativeName = "LuaCodeEdit";

    #region Inherited Properties

    public bool SymbolLookupOnClick
    {
        get => Object.SymbolLookupOnClick;
        set => Object.SymbolLookupOnClick = value;
    }

    public bool SymbolTooltipOnHover
    {
        get => Object.SymbolTooltipOnHover;
        set => Object.SymbolTooltipOnHover = value;
    }

    public bool LineFolding
    {
        get => Object.LineFolding;
        set => Object.LineFolding = value;
    }

    public int[] LineLengthGuidelines
    {
        get => Variant.From(Object.LineLengthGuidelines).AsInt32Array();
        set => Object.LineLengthGuidelines = Variant.From(value).AsGodotArray<int>();
    }

    public bool GuttersDrawBreakpointsGutter
    {
        get => Object.GuttersDrawBreakpointsGutter;
        set => Object.GuttersDrawBreakpointsGutter = value;
    }

    public bool GuttersDrawBookmarks
    {
        get => Object.GuttersDrawBookmarks;
        set => Object.GuttersDrawBookmarks = value;
    }

    public bool GuttersDrawExecutingLines
    {
        get => Object.GuttersDrawExecutingLines;
        set => Object.GuttersDrawExecutingLines = value;
    }

    public bool GuttersDrawLineNumbers
    {
        get => Object.GuttersDrawLineNumbers;
        set => Object.GuttersDrawLineNumbers = value;
    }

    public bool GuttersZeroPadLineNumbers
    {
        get => Object.GuttersZeroPadLineNumbers;
        set => Object.GuttersZeroPadLineNumbers = value;
    }

    public bool GuttersDrawFoldGutter
    {
        get => Object.GuttersDrawFoldGutter;
        set => Object.GuttersDrawFoldGutter = value;
    }

    public string[] DelimiterStrings
    {
        get => Variant.From(Object.DelimiterStrings).AsStringArray();
        set => Object.DelimiterStrings = Variant.From(value).AsGodotArray<string>();
    }

    public string[] DelimiterComments
    {
        get => Variant.From(Object.DelimiterComments).AsStringArray();
        set => Object.DelimiterComments = Variant.From(value).AsGodotArray<string>();
    }

    public bool CodeCompletionEnabled
    {
        get => Object.CodeCompletionEnabled;
        set => Object.CodeCompletionEnabled = value;
    }

    public string[] CodeCompletionPrefixes
    {
        get => Variant.From(Object.CodeCompletionPrefixes).AsStringArray();
        set => Object.CodeCompletionPrefixes = Variant.From(value).AsGodotArray<string>();
    }

    public int IndentSize
    {
        get => Object.IndentSize;
        set => Object.IndentSize = value;
    }

    public bool IndentUseSpaces
    {
        get => Object.IndentUseSpaces;
        set => Object.IndentUseSpaces = value;
    }

    public bool IndentAutomatic
    {
        get => Object.IndentAutomatic;
        set => Object.IndentAutomatic = value;
    }

    public string[] IndentAutomaticPrefixes
    {
        get => Variant.From(Object.IndentAutomaticPrefixes).AsStringArray();
        set => Object.IndentAutomaticPrefixes = Variant.From(value).AsGodotArray<string>();
    }

    public bool AutoBraceCompletionEnabled
    {
        get => Object.AutoBraceCompletionEnabled;
        set => Object.AutoBraceCompletionEnabled = value;
    }

    public bool AutoBraceCompletionHighlightMatching
    {
        get => Object.AutoBraceCompletionHighlightMatching;
        set => Object.AutoBraceCompletionHighlightMatching = value;
    }

    public Dictionary AutoBraceCompletionPairs
    {
        get => Object.AutoBraceCompletionPairs;
        set => Object.AutoBraceCompletionPairs = value;
    }

    public string Text
    {
        get => Object.Text;
        set => Object.Text = value;
    }

    public string PlaceholderText
    {
        get => Object.PlaceholderText;
        set => Object.PlaceholderText = value;
    }

    public bool Editable
    {
        get => Object.Editable;
        set => Object.Editable = value;
    }

    public bool ContextMenuEnabled
    {
        get => Object.ContextMenuEnabled;
        set => Object.ContextMenuEnabled = value;
    }

    public bool EmojiMenuEnabled
    {
        get => Object.EmojiMenuEnabled;
        set => Object.EmojiMenuEnabled = value;
    }

    public bool BackspaceDeletesCompositeCharacterEnabled
    {
        get => Object.BackspaceDeletesCompositeCharacterEnabled;
        set => Object.BackspaceDeletesCompositeCharacterEnabled = value;
    }

    public bool ShortcutKeysEnabled
    {
        get => Object.ShortcutKeysEnabled;
        set => Object.ShortcutKeysEnabled = value;
    }

    public bool SelectingEnabled
    {
        get => Object.SelectingEnabled;
        set => Object.SelectingEnabled = value;
    }

    public bool DeselectOnFocusLossEnabled
    {
        get => Object.DeselectOnFocusLossEnabled;
        set => Object.DeselectOnFocusLossEnabled = value;
    }

    public bool DragAndDropSelectionEnabled
    {
        get => Object.DragAndDropSelectionEnabled;
        set => Object.DragAndDropSelectionEnabled = value;
    }

    public bool VirtualKeyboardEnabled
    {
        get => Object.VirtualKeyboardEnabled;
        set => Object.VirtualKeyboardEnabled = value;
    }

    public bool VirtualKeyboardShowOnFocus
    {
        get => Object.VirtualKeyboardShowOnFocus;
        set => Object.VirtualKeyboardShowOnFocus = value;
    }

    public bool MiddleMousePasteEnabled
    {
        get => Object.MiddleMousePasteEnabled;
        set => Object.MiddleMousePasteEnabled = value;
    }

    public bool EmptySelectionClipboardEnabled
    {
        get => Object.EmptySelectionClipboardEnabled;
        set => Object.EmptySelectionClipboardEnabled = value;
    }

    public TextEdit.LineWrappingMode WrapMode
    {
        get => Object.WrapMode;
        set => Object.WrapMode = value;
    }

    public TextServer.AutowrapMode AutowrapMode
    {
        get => Object.AutowrapMode;
        set => Object.AutowrapMode = value;
    }

    public bool IndentWrappedLines
    {
        get => Object.IndentWrappedLines;
        set => Object.IndentWrappedLines = value;
    }

    public bool TabInputMode
    {
        get => Object.TabInputMode;
        set => Object.TabInputMode = value;
    }

    public bool ScrollSmooth
    {
        get => Object.ScrollSmooth;
        set => Object.ScrollSmooth = value;
    }

    public float ScrollVScrollSpeed
    {
        get => Object.ScrollVScrollSpeed;
        set => Object.ScrollVScrollSpeed = value;
    }

    public bool ScrollPastEndOfFile
    {
        get => Object.ScrollPastEndOfFile;
        set => Object.ScrollPastEndOfFile = value;
    }

    public double ScrollVertical
    {
        get => Object.ScrollVertical;
        set => Object.ScrollVertical = value;
    }

    public int ScrollHorizontal
    {
        get => Object.ScrollHorizontal;
        set => Object.ScrollHorizontal = value;
    }

    public bool ScrollFitContentHeight
    {
        get => Object.ScrollFitContentHeight;
        set => Object.ScrollFitContentHeight = value;
    }

    public bool ScrollFitContentWidth
    {
        get => Object.ScrollFitContentWidth;
        set => Object.ScrollFitContentWidth = value;
    }

    public bool MinimapDraw
    {
        get => Object.MinimapDraw;
        set => Object.MinimapDraw = value;
    }

    public int MinimapWidth
    {
        get => Object.MinimapWidth;
        set => Object.MinimapWidth = value;
    }

    public TextEdit.CaretTypeEnum CaretType
    {
        get => Object.CaretType;
        set => Object.CaretType = value;
    }

    public bool CaretBlink
    {
        get => Object.CaretBlink;
        set => Object.CaretBlink = value;
    }

    public float CaretBlinkInterval
    {
        get => Object.CaretBlinkInterval;
        set => Object.CaretBlinkInterval = value;
    }

    public bool CaretDrawWhenEditableDisabled
    {
        get => Object.CaretDrawWhenEditableDisabled;
        set => Object.CaretDrawWhenEditableDisabled = value;
    }

    public bool CaretMoveOnRightClick
    {
        get => Object.CaretMoveOnRightClick;
        set => Object.CaretMoveOnRightClick = value;
    }

    public bool CaretMidGrapheme
    {
        get => Object.CaretMidGrapheme;
        set => Object.CaretMidGrapheme = value;
    }

    public bool CaretMultiple
    {
        get => Object.CaretMultiple;
        set => Object.CaretMultiple = value;
    }

    public bool UseDefaultWordSeparators
    {
        get => Object.UseDefaultWordSeparators;
        set => Object.UseDefaultWordSeparators = value;
    }

    public bool UseCustomWordSeparators
    {
        get => Object.UseCustomWordSeparators;
        set => Object.UseCustomWordSeparators = value;
    }

    public string CustomWordSeparators
    {
        get => Object.CustomWordSeparators;
        set => Object.CustomWordSeparators = value;
    }

    public SyntaxHighlighter SyntaxHighlighter
    {
        get => Object.SyntaxHighlighter;
        set => Object.SyntaxHighlighter = value;
    }

    public bool HighlightAllOccurrences
    {
        get => Object.HighlightAllOccurrences;
        set => Object.HighlightAllOccurrences = value;
    }

    public bool HighlightCurrentLine
    {
        get => Object.HighlightCurrentLine;
        set => Object.HighlightCurrentLine = value;
    }

    public bool DrawControlChars
    {
        get => Object.DrawControlChars;
        set => Object.DrawControlChars = value;
    }

    public bool DrawTabs
    {
        get => Object.DrawTabs;
        set => Object.DrawTabs = value;
    }

    public bool DrawSpaces
    {
        get => Object.DrawSpaces;
        set => Object.DrawSpaces = value;
    }

    public Control.TextDirection TextDirection
    {
        get => Object.TextDirection;
        set => Object.TextDirection = value;
    }

    public string Language
    {
        get => Object.Language;
        set => Object.Language = value;
    }

    public TextServer.StructuredTextParser StructuredTextBidiOverride
    {
        get => Object.StructuredTextBidiOverride;
        set => Object.StructuredTextBidiOverride = value;
    }

    public Godot.Collections.Array StructuredTextBidiOverrideOptions
    {
        get => Object.StructuredTextBidiOverrideOptions;
        set => Object.StructuredTextBidiOverrideOptions = value;
    }

    public bool ClipContents
    {
        get => Object.ClipContents;
        set => Object.ClipContents = value;
    }

    public Vector2 CustomMinimumSize
    {
        get => Object.CustomMinimumSize;
        set => Object.CustomMinimumSize = value;
    }

    public Control.LayoutDirectionEnum LayoutDirection
    {
        get => Object.LayoutDirection;
        set => Object.LayoutDirection = value;
    }

    public int LayoutMode
    {
        get => Object.LayoutMode;
        set => Object.LayoutMode = value;
    }

    public int AnchorsPreset
    {
        get => Object.AnchorsPreset;
        set => Object.AnchorsPreset = value;
    }

    public float AnchorLeft
    {
        get => Object.AnchorLeft;
        set => Object.AnchorLeft = value;
    }

    public float AnchorTop
    {
        get => Object.AnchorTop;
        set => Object.AnchorTop = value;
    }

    public float AnchorRight
    {
        get => Object.AnchorRight;
        set => Object.AnchorRight = value;
    }

    public float AnchorBottom
    {
        get => Object.AnchorBottom;
        set => Object.AnchorBottom = value;
    }

    public float OffsetLeft
    {
        get => Object.OffsetLeft;
        set => Object.OffsetLeft = value;
    }

    public float OffsetTop
    {
        get => Object.OffsetTop;
        set => Object.OffsetTop = value;
    }

    public float OffsetRight
    {
        get => Object.OffsetRight;
        set => Object.OffsetRight = value;
    }

    public float OffsetBottom
    {
        get => Object.OffsetBottom;
        set => Object.OffsetBottom = value;
    }

    public Control.GrowDirection GrowHorizontal
    {
        get => Object.GrowHorizontal;
        set => Object.GrowHorizontal = value;
    }

    public Control.GrowDirection GrowVertical
    {
        get => Object.GrowVertical;
        set => Object.GrowVertical = value;
    }

    public Vector2 Size
    {
        get => Object.Size;
        set => Object.Size = value;
    }

    public Vector2 Position
    {
        get => Object.Position;
        set => Object.Position = value;
    }

    public Vector2 GlobalPosition
    {
        get => Object.GlobalPosition;
        set => Object.GlobalPosition = value;
    }

    public float Rotation
    {
        get => Object.Rotation;
        set => Object.Rotation = value;
    }

    public float RotationDegrees
    {
        get => Object.RotationDegrees;
        set => Object.RotationDegrees = value;
    }

    public Vector2 Scale
    {
        get => Object.Scale;
        set => Object.Scale = value;
    }

    public Vector2 PivotOffset
    {
        get => Object.PivotOffset;
        set => Object.PivotOffset = value;
    }

    public Control.SizeFlags SizeFlagsHorizontal
    {
        get => Object.SizeFlagsHorizontal;
        set => Object.SizeFlagsHorizontal = value;
    }

    public Control.SizeFlags SizeFlagsVertical
    {
        get => Object.SizeFlagsVertical;
        set => Object.SizeFlagsVertical = value;
    }

    public float SizeFlagsStretchRatio
    {
        get => Object.SizeFlagsStretchRatio;
        set => Object.SizeFlagsStretchRatio = value;
    }

    public bool LocalizeNumeralSystem
    {
        get => Object.LocalizeNumeralSystem;
        set => Object.LocalizeNumeralSystem = value;
    }

    [Obsolete("Use 'Godot.Node.AutoTranslateMode' and 'Godot.Node.CanAutoTranslate()' instead.")]
    public bool AutoTranslate
    {
        get => Object.AutoTranslate;
        set => Object.AutoTranslate = value;
    }

    public string TooltipText
    {
        get => Object.TooltipText;
        set => Object.TooltipText = value;
    }

    public Node.AutoTranslateModeEnum TooltipAutoTranslateMode
    {
        get => Object.TooltipAutoTranslateMode;
        set => Object.TooltipAutoTranslateMode = value;
    }

    public NodePath FocusNeighborLeft
    {
        get => Object.FocusNeighborLeft;
        set => Object.FocusNeighborLeft = value;
    }

    public NodePath FocusNeighborTop
    {
        get => Object.FocusNeighborTop;
        set => Object.FocusNeighborTop = value;
    }

    public NodePath FocusNeighborRight
    {
        get => Object.FocusNeighborRight;
        set => Object.FocusNeighborRight = value;
    }

    public NodePath FocusNeighborBottom
    {
        get => Object.FocusNeighborBottom;
        set => Object.FocusNeighborBottom = value;
    }

    public NodePath FocusNext
    {
        get => Object.FocusNext;
        set => Object.FocusNext = value;
    }

    public NodePath FocusPrevious
    {
        get => Object.FocusPrevious;
        set => Object.FocusPrevious = value;
    }

    public Control.FocusModeEnum FocusMode
    {
        get => Object.FocusMode;
        set => Object.FocusMode = value;
    }

    public Control.FocusBehaviorRecursiveEnum FocusBehaviorRecursive
    {
        get => Object.FocusBehaviorRecursive;
        set => Object.FocusBehaviorRecursive = value;
    }

    public Control.MouseFilterEnum MouseFilter
    {
        get => Object.MouseFilter;
        set => Object.MouseFilter = value;
    }

    public Control.MouseBehaviorRecursiveEnum MouseBehaviorRecursive
    {
        get => Object.MouseBehaviorRecursive;
        set => Object.MouseBehaviorRecursive = value;
    }

    public bool MouseForcePassScrollEvents
    {
        get => Object.MouseForcePassScrollEvents;
        set => Object.MouseForcePassScrollEvents = value;
    }

    public Control.CursorShape MouseDefaultCursorShape
    {
        get => Object.MouseDefaultCursorShape;
        set => Object.MouseDefaultCursorShape = value;
    }

    public Node ShortcutContext
    {
        get => Object.ShortcutContext;
        set => Object.ShortcutContext = value;
    }

    public string AccessibilityName
    {
        get => Object.AccessibilityName;
        set => Object.AccessibilityName = value;
    }

    public string AccessibilityDescription
    {
        get => Object.AccessibilityDescription;
        set => Object.AccessibilityDescription = value;
    }

    public DisplayServer.AccessibilityLiveMode AccessibilityLive
    {
        get => Object.AccessibilityLive;
        set => Object.AccessibilityLive = value;
    }

    public Array<NodePath> AccessibilityControlsNodes
    {
        get => Object.AccessibilityControlsNodes;
        set => Object.AccessibilityControlsNodes = value;
    }

    public Array<NodePath> AccessibilityDescribedByNodes
    {
        get => Object.AccessibilityDescribedByNodes;
        set => Object.AccessibilityDescribedByNodes = value;
    }

    public Array<NodePath> AccessibilityLabeledByNodes
    {
        get => Object.AccessibilityLabeledByNodes;
        set => Object.AccessibilityLabeledByNodes = value;
    }

    public Array<NodePath> AccessibilityFlowToNodes
    {
        get => Object.AccessibilityFlowToNodes;
        set => Object.AccessibilityFlowToNodes = value;
    }

    public Theme Theme
    {
        get => Object.Theme;
        set => Object.Theme = value;
    }

    public string ThemeTypeVariation
    {
        get => Object.ThemeTypeVariation;
        set => Object.ThemeTypeVariation = value;
    }

    public bool Visible
    {
        get => Object.Visible;
        set => Object.Visible = value;
    }

    public Color Modulate
    {
        get => Object.Modulate;
        set => Object.Modulate = value;
    }

    public Color SelfModulate
    {
        get => Object.SelfModulate;
        set => Object.SelfModulate = value;
    }

    public bool ShowBehindParent
    {
        get => Object.ShowBehindParent;
        set => Object.ShowBehindParent = value;
    }

    public bool TopLevel
    {
        get => Object.TopLevel;
        set => Object.TopLevel = value;
    }

    public CanvasItem.ClipChildrenMode ClipChildren
    {
        get => Object.ClipChildren;
        set => Object.ClipChildren = value;
    }

    public int LightMask
    {
        get => Object.LightMask;
        set => Object.LightMask = value;
    }

    public uint VisibilityLayer
    {
        get => Object.VisibilityLayer;
        set => Object.VisibilityLayer = value;
    }

    public int ZIndex
    {
        get => Object.ZIndex;
        set => Object.ZIndex = value;
    }

    public bool ZAsRelative
    {
        get => Object.ZAsRelative;
        set => Object.ZAsRelative = value;
    }

    public bool YSortEnabled
    {
        get => Object.YSortEnabled;
        set => Object.YSortEnabled = value;
    }

    public CanvasItem.TextureFilterEnum TextureFilter
    {
        get => Object.TextureFilter;
        set => Object.TextureFilter = value;
    }

    public CanvasItem.TextureRepeatEnum TextureRepeat
    {
        get => Object.TextureRepeat;
        set => Object.TextureRepeat = value;
    }

    public Material Material
    {
        get => Object.Material;
        set => Object.Material = value;
    }

    public bool UseParentMaterial
    {
        get => Object.UseParentMaterial;
        set => Object.UseParentMaterial = value;
    }

    // public NodePath ImportPath
    // {
    //     get => Object.ImportPath;
    //     set => Object.ImportPath = value;
    // }

    public StringName Name
    {
        get => Object.Name;
        set => Object.Name = value;
    }

    public bool UniqueNameInOwner
    {
        get => Object.UniqueNameInOwner;
        set => Object.UniqueNameInOwner = value;
    }

    public string SceneFilePath
    {
        get => Object.SceneFilePath;
        set => Object.SceneFilePath = value;
    }

    public Node Owner
    {
        get => Object.Owner;
        set => Object.Owner = value;
    }

    public MultiplayerApi Multiplayer => Object.Multiplayer;

    public Node.ProcessModeEnum ProcessMode
    {
        get => Object.ProcessMode;
        set => Object.ProcessMode = value;
    }

    public int ProcessPriority
    {
        get => Object.ProcessPriority;
        set => Object.ProcessPriority = value;
    }

    public int ProcessPhysicsPriority
    {
        get => Object.ProcessPhysicsPriority;
        set => Object.ProcessPhysicsPriority = value;
    }

    public Node.ProcessThreadGroupEnum ProcessThreadGroup
    {
        get => Object.ProcessThreadGroup;
        set => Object.ProcessThreadGroup = value;
    }

    public int ProcessThreadGroupOrder
    {
        get => Object.ProcessThreadGroupOrder;
        set => Object.ProcessThreadGroupOrder = value;
    }

    public Node.ProcessThreadMessagesEnum ProcessThreadMessages
    {
        get => Object.ProcessThreadMessages;
        set => Object.ProcessThreadMessages = value;
    }

    public Node.PhysicsInterpolationModeEnum PhysicsInterpolationMode
    {
        get => Object.PhysicsInterpolationMode;
        set => Object.PhysicsInterpolationMode = value;
    }

    public Node.AutoTranslateModeEnum AutoTranslateMode
    {
        get => Object.AutoTranslateMode;
        set => Object.AutoTranslateMode = value;
    }

    public string EditorDescription
    {
        get => Object.EditorDescription;
        set => Object.EditorDescription = value;
    }

    #endregion

    #region Inherited Methods

    public void SetIndentSize(int size)
    {
        Object.SetIndentSize(size);
    }

    public int GetIndentSize()
    {
        return Object.GetIndentSize();
    }

    public void SetIndentUsingSpaces(bool useSpaces)
    {
        Object.SetIndentUsingSpaces(useSpaces);
    }

    public bool IsIndentUsingSpaces()
    {
        return Object.IsIndentUsingSpaces();
    }

    public void SetAutoIndentEnabled(bool enable)
    {
        Object.SetAutoIndentEnabled(enable);
    }

    public bool IsAutoIndentEnabled()
    {
        return Object.IsAutoIndentEnabled();
    }

    public void SetAutoIndentPrefixes(Array<string> prefixes)
    {
        Object.SetAutoIndentPrefixes(prefixes);
    }

    public Array<string> GetAutoIndentPrefixes()
    {
        return Object.GetAutoIndentPrefixes();
    }

    public void DoIndent()
    {
        Object.DoIndent();
    }

    public void IndentLines()
    {
        Object.IndentLines();
    }

    public void UnindentLines()
    {
        Object.UnindentLines();
    }

    public void ConvertIndent(int fromLine = -1, int toLine = -1)
    {
        Object.ConvertIndent(fromLine, toLine);
    }

    public void SetAutoBraceCompletionEnabled(bool enable)
    {
        Object.SetAutoBraceCompletionEnabled(enable);
    }

    public bool IsAutoBraceCompletionEnabled()
    {
        return Object.IsAutoBraceCompletionEnabled();
    }

    public void SetHighlightMatchingBracesEnabled(bool enable)
    {
        Object.SetHighlightMatchingBracesEnabled(enable);
    }

    public bool IsHighlightMatchingBracesEnabled()
    {
        return Object.IsHighlightMatchingBracesEnabled();
    }

    public void AddAutoBraceCompletionPair(string startKey, string endKey)
    {
        Object.AddAutoBraceCompletionPair(startKey, endKey);
    }

    public void SetAutoBraceCompletionPairs(Dictionary pairs)
    {
        Object.SetAutoBraceCompletionPairs(pairs);
    }

    public Dictionary GetAutoBraceCompletionPairs()
    {
        return Object.GetAutoBraceCompletionPairs();
    }

    public bool HasAutoBraceCompletionOpenKey(string openKey)
    {
        return Object.HasAutoBraceCompletionOpenKey(openKey);
    }

    public bool HasAutoBraceCompletionCloseKey(string closeKey)
    {
        return Object.HasAutoBraceCompletionCloseKey(closeKey);
    }

    public string GetAutoBraceCompletionCloseKey(string openKey)
    {
        return Object.GetAutoBraceCompletionCloseKey(openKey);
    }

    public void SetDrawBreakpointsGutter(bool enable)
    {
        Object.SetDrawBreakpointsGutter(enable);
    }

    public bool IsDrawingBreakpointsGutter()
    {
        return Object.IsDrawingBreakpointsGutter();
    }

    public void SetDrawBookmarksGutter(bool enable)
    {
        Object.SetDrawBookmarksGutter(enable);
    }

    public bool IsDrawingBookmarksGutter()
    {
        return Object.IsDrawingBookmarksGutter();
    }

    public void SetDrawExecutingLinesGutter(bool enable)
    {
        Object.SetDrawExecutingLinesGutter(enable);
    }

    public bool IsDrawingExecutingLinesGutter()
    {
        return Object.IsDrawingExecutingLinesGutter();
    }

    public void SetLineAsBreakpoint(int line, bool breakpointed)
    {
        Object.SetLineAsBreakpoint(line, breakpointed);
    }

    public bool IsLineBreakpointed(int line)
    {
        return Object.IsLineBreakpointed(line);
    }

    public void ClearBreakpointedLines()
    {
        Object.ClearBreakpointedLines();
    }

    public int[] GetBreakpointedLines()
    {
        return Object.GetBreakpointedLines();
    }

    public void SetLineAsBookmarked(int line, bool bookmarked)
    {
        Object.SetLineAsBookmarked(line, bookmarked);
    }

    public bool IsLineBookmarked(int line)
    {
        return Object.IsLineBookmarked(line);
    }

    public void ClearBookmarkedLines()
    {
        Object.ClearBookmarkedLines();
    }

    public int[] GetBookmarkedLines()
    {
        return Object.GetBookmarkedLines();
    }

    public void SetLineAsExecuting(int line, bool executing)
    {
        Object.SetLineAsExecuting(line, executing);
    }

    public bool IsLineExecuting(int line)
    {
        return Object.IsLineExecuting(line);
    }

    public void ClearExecutingLines()
    {
        Object.ClearExecutingLines();
    }

    public int[] GetExecutingLines()
    {
        return Object.GetExecutingLines();
    }

    public void SetDrawLineNumbers(bool enable)
    {
        Object.SetDrawLineNumbers(enable);
    }

    public bool IsDrawLineNumbersEnabled()
    {
        return Object.IsDrawLineNumbersEnabled();
    }

    public void SetLineNumbersZeroPadded(bool enable)
    {
        Object.SetLineNumbersZeroPadded(enable);
    }

    public bool IsLineNumbersZeroPadded()
    {
        return Object.IsLineNumbersZeroPadded();
    }

    public void SetDrawFoldGutter(bool enable)
    {
        Object.SetDrawFoldGutter(enable);
    }

    public bool IsDrawingFoldGutter()
    {
        return Object.IsDrawingFoldGutter();
    }

    public void SetLineFoldingEnabled(bool enabled)
    {
        Object.SetLineFoldingEnabled(enabled);
    }

    public bool IsLineFoldingEnabled()
    {
        return Object.IsLineFoldingEnabled();
    }

    public bool CanFoldLine(int line)
    {
        return Object.CanFoldLine(line);
    }

    public void FoldLine(int line)
    {
        Object.FoldLine(line);
    }

    public void UnfoldLine(int line)
    {
        Object.UnfoldLine(line);
    }

    public void FoldAllLines()
    {
        Object.FoldAllLines();
    }

    public void UnfoldAllLines()
    {
        Object.UnfoldAllLines();
    }

    public void ToggleFoldableLine(int line)
    {
        Object.ToggleFoldableLine(line);
    }

    public void ToggleFoldableLinesAtCarets()
    {
        Object.ToggleFoldableLinesAtCarets();
    }

    public bool IsLineFolded(int line)
    {
        return Object.IsLineFolded(line);
    }

    public Array<int> GetFoldedLines()
    {
        return Object.GetFoldedLines();
    }

    public void CreateCodeRegion()
    {
        Object.CreateCodeRegion();
    }

    public string GetCodeRegionStartTag()
    {
        return Object.GetCodeRegionStartTag();
    }

    public string GetCodeRegionEndTag()
    {
        return Object.GetCodeRegionEndTag();
    }

    public void SetCodeRegionTags(string start = "region", string end = "endregion")
    {
        Object.SetCodeRegionTags(start, end);
    }

    public bool IsLineCodeRegionStart(int line)
    {
        return Object.IsLineCodeRegionStart(line);
    }

    public bool IsLineCodeRegionEnd(int line)
    {
        return Object.IsLineCodeRegionEnd(line);
    }

    public void AddStringDelimiter(string startKey, string endKey, bool lineOnly = false)
    {
        Object.AddStringDelimiter(startKey, endKey, lineOnly);
    }

    public void RemoveStringDelimiter(string startKey)
    {
        Object.RemoveStringDelimiter(startKey);
    }

    public bool HasStringDelimiter(string startKey)
    {
        return Object.HasStringDelimiter(startKey);
    }

    public void SetStringDelimiters(Array<string> stringDelimiters)
    {
        Object.SetStringDelimiters(stringDelimiters);
    }

    public void ClearStringDelimiters()
    {
        Object.ClearStringDelimiters();
    }

    public Array<string> GetStringDelimiters()
    {
        return Object.GetStringDelimiters();
    }

    public int IsInString(int line, int column = -1)
    {
        return Object.IsInString(line, column);
    }

    public void AddCommentDelimiter(string startKey, string endKey, bool lineOnly = false)
    {
        Object.AddCommentDelimiter(startKey, endKey, lineOnly);
    }

    public void RemoveCommentDelimiter(string startKey)
    {
        Object.RemoveCommentDelimiter(startKey);
    }

    public bool HasCommentDelimiter(string startKey)
    {
        return Object.HasCommentDelimiter(startKey);
    }

    public void SetCommentDelimiters(Array<string> commentDelimiters)
    {
        Object.SetCommentDelimiters(commentDelimiters);
    }

    public void ClearCommentDelimiters()
    {
        Object.ClearCommentDelimiters();
    }

    public Array<string> GetCommentDelimiters()
    {
        return Object.GetCommentDelimiters();
    }

    public int IsInComment(int line, int column = -1)
    {
        return Object.IsInComment(line, column);
    }

    public string GetDelimiterStartKey(int delimiterIndex)
    {
        return Object.GetDelimiterStartKey(delimiterIndex);
    }

    public string GetDelimiterEndKey(int delimiterIndex)
    {
        return Object.GetDelimiterEndKey(delimiterIndex);
    }

    public Vector2 GetDelimiterStartPosition(int line, int column)
    {
        return Object.GetDelimiterStartPosition(line, column);
    }

    public Vector2 GetDelimiterEndPosition(int line, int column)
    {
        return Object.GetDelimiterEndPosition(line, column);
    }

    public void SetCodeHint(string codeHint)
    {
        Object.SetCodeHint(codeHint);
    }

    public void SetCodeHintDrawBelow(bool drawBelow)
    {
        Object.SetCodeHintDrawBelow(drawBelow);
    }

    public string GetTextForCodeCompletion()
    {
        return Object.GetTextForCodeCompletion();
    }

    public void RequestCodeCompletion(bool force = false)
    {
        Object.RequestCodeCompletion(force);
    }

    public void AddCodeCompletionOption(CodeEdit.CodeCompletionKind type, string displayText, string insertText,
        Color? textColor = null, Resource? icon = null, Variant value = default, int location = 1024)
    {
        textColor ??= new Color(1.0f, 1.0f, 1.0f);
        Object.AddCodeCompletionOption(type, displayText, insertText, textColor, icon, value, location);
    }

    public void UpdateCodeCompletionOptions(bool force)
    {
        Object.UpdateCodeCompletionOptions(force);
    }

    public Array<Dictionary> GetCodeCompletionOptions()
    {
        return Object.GetCodeCompletionOptions();
    }

    public Dictionary GetCodeCompletionOption(int index)
    {
        return Object.GetCodeCompletionOption(index);
    }

    public int GetCodeCompletionSelectedIndex()
    {
        return Object.GetCodeCompletionSelectedIndex();
    }

    public void SetCodeCompletionSelectedIndex(int index)
    {
        Object.SetCodeCompletionSelectedIndex(index);
    }

    public void ConfirmCodeCompletion(bool replace = false)
    {
        Object.ConfirmCodeCompletion(replace);
    }

    public void CancelCodeCompletion()
    {
        Object.CancelCodeCompletion();
    }

    public void SetCodeCompletionEnabled(bool enable)
    {
        Object.SetCodeCompletionEnabled(enable);
    }

    public bool IsCodeCompletionEnabled()
    {
        return Object.IsCodeCompletionEnabled();
    }

    public void SetCodeCompletionPrefixes(Array<string> prefixes)
    {
        Object.SetCodeCompletionPrefixes(prefixes);
    }

    public Array<string> GetCodeCompletionPrefixes()
    {
        return Object.GetCodeCompletionPrefixes();
    }

    public void SetLineLengthGuidelines(Array<int> guidelineColumns)
    {
        Object.SetLineLengthGuidelines(guidelineColumns);
    }

    public Array<int> GetLineLengthGuidelines()
    {
        return Object.GetLineLengthGuidelines();
    }

    public void SetSymbolLookupOnClickEnabled(bool enable)
    {
        Object.SetSymbolLookupOnClickEnabled(enable);
    }

    public bool IsSymbolLookupOnClickEnabled()
    {
        return Object.IsSymbolLookupOnClickEnabled();
    }

    public string GetTextForSymbolLookup()
    {
        return Object.GetTextForSymbolLookup();
    }

    public string GetTextWithCursorChar(int line, int column)
    {
        return Object.GetTextWithCursorChar(line, column);
    }

    public void SetSymbolLookupWordAsValid(bool valid)
    {
        Object.SetSymbolLookupWordAsValid(valid);
    }

    public void SetSymbolTooltipOnHoverEnabled(bool enable)
    {
        Object.SetSymbolTooltipOnHoverEnabled(enable);
    }

    public bool IsSymbolTooltipOnHoverEnabled()
    {
        return Object.IsSymbolTooltipOnHoverEnabled();
    }

    public void MoveLinesUp()
    {
        Object.MoveLinesUp();
    }

    public void MoveLinesDown()
    {
        Object.MoveLinesDown();
    }

    public void DeleteLines()
    {
        Object.DeleteLines();
    }

    public void DuplicateSelection()
    {
        Object.DuplicateSelection();
    }

    public void DuplicateLines()
    {
        Object.DuplicateLines();
    }

    public bool HasImeText()
    {
        return Object.HasImeText();
    }

    public void CancelIme()
    {
        Object.CancelIme();
    }

    public void ApplyIme()
    {
        Object.ApplyIme();
    }

    public void SetEditable(bool enabled)
    {
        Object.SetEditable(enabled);
    }

    public bool IsEditable()
    {
        return Object.IsEditable();
    }

    public void SetTextDirection(Control.TextDirection direction)
    {
        Object.SetTextDirection(direction);
    }

    public Control.TextDirection GetTextDirection()
    {
        return Object.GetTextDirection();
    }

    public void SetLanguage(string language)
    {
        Object.SetLanguage(language);
    }

    public string GetLanguage()
    {
        return Object.GetLanguage();
    }

    public void SetStructuredTextBidiOverride(TextServer.StructuredTextParser parser)
    {
        Object.SetStructuredTextBidiOverride(parser);
    }

    public TextServer.StructuredTextParser GetStructuredTextBidiOverride()
    {
        return Object.GetStructuredTextBidiOverride();
    }

    public void SetStructuredTextBidiOverrideOptions(Godot.Collections.Array args)
    {
        Object.SetStructuredTextBidiOverrideOptions(args);
    }

    public Godot.Collections.Array GetStructuredTextBidiOverrideOptions()
    {
        return Object.GetStructuredTextBidiOverrideOptions();
    }

    public void SetTabSize(int size)
    {
        Object.SetTabSize(size);
    }

    public int GetTabSize()
    {
        return Object.GetTabSize();
    }

    public void SetIndentWrappedLines(bool enabled)
    {
        Object.SetIndentWrappedLines(enabled);
    }

    public bool IsIndentWrappedLines()
    {
        return Object.IsIndentWrappedLines();
    }

    public void SetTabInputMode(bool enabled)
    {
        Object.SetTabInputMode(enabled);
    }

    public bool GetTabInputMode()
    {
        return Object.GetTabInputMode();
    }

    public void SetOvertypeModeEnabled(bool enabled)
    {
        Object.SetOvertypeModeEnabled(enabled);
    }

    public bool IsOvertypeModeEnabled()
    {
        return Object.IsOvertypeModeEnabled();
    }

    public void SetContextMenuEnabled(bool enabled)
    {
        Object.SetContextMenuEnabled(enabled);
    }

    public bool IsContextMenuEnabled()
    {
        return Object.IsContextMenuEnabled();
    }

    public void SetEmojiMenuEnabled(bool enable)
    {
        Object.SetEmojiMenuEnabled(enable);
    }

    public bool IsEmojiMenuEnabled()
    {
        return Object.IsEmojiMenuEnabled();
    }

    public void SetBackspaceDeletesCompositeCharacterEnabled(bool enable)
    {
        Object.SetBackspaceDeletesCompositeCharacterEnabled(enable);
    }

    public bool IsBackspaceDeletesCompositeCharacterEnabled()
    {
        return Object.IsBackspaceDeletesCompositeCharacterEnabled();
    }

    public void SetShortcutKeysEnabled(bool enabled)
    {
        Object.SetShortcutKeysEnabled(enabled);
    }

    public bool IsShortcutKeysEnabled()
    {
        return Object.IsShortcutKeysEnabled();
    }

    public void SetVirtualKeyboardEnabled(bool enabled)
    {
        Object.SetVirtualKeyboardEnabled(enabled);
    }

    public bool IsVirtualKeyboardEnabled()
    {
        return Object.IsVirtualKeyboardEnabled();
    }

    public void SetVirtualKeyboardShowOnFocus(bool showOnFocus)
    {
        Object.SetVirtualKeyboardShowOnFocus(showOnFocus);
    }

    public bool GetVirtualKeyboardShowOnFocus()
    {
        return Object.GetVirtualKeyboardShowOnFocus();
    }

    public void SetMiddleMousePasteEnabled(bool enabled)
    {
        Object.SetMiddleMousePasteEnabled(enabled);
    }

    public bool IsMiddleMousePasteEnabled()
    {
        return Object.IsMiddleMousePasteEnabled();
    }

    public void SetEmptySelectionClipboardEnabled(bool enabled)
    {
        Object.SetEmptySelectionClipboardEnabled(enabled);
    }

    public bool IsEmptySelectionClipboardEnabled()
    {
        return Object.IsEmptySelectionClipboardEnabled();
    }

    public void Clear()
    {
        Object.Clear();
    }

    public void SetText(string text)
    {
        Object.SetText(text);
    }

    public string GetText()
    {
        return Object.GetText();
    }

    public int GetLineCount()
    {
        return Object.GetLineCount();
    }

    public void SetPlaceholder(string text)
    {
        Object.SetPlaceholder(text);
    }

    public string GetPlaceholder()
    {
        return Object.GetPlaceholder();
    }

    public void SetLine(int line, string newText)
    {
        Object.SetLine(line, newText);
    }

    public string GetLine(int line)
    {
        return Object.GetLine(line);
    }

    public string GetLineWithIme(int line)
    {
        return Object.GetLineWithIme(line);
    }

    public int GetLineWidth(int line, int wrapIndex = -1)
    {
        return Object.GetLineWidth(line, wrapIndex);
    }

    public int GetLineHeight()
    {
        return Object.GetLineHeight();
    }

    public int GetIndentLevel(int line)
    {
        return Object.GetIndentLevel(line);
    }

    // public int GetFirstNonWhitespaceColumn(int line)
    // {
    //     return Object.GetFirstNonWhitespaceColumn(line);
    // }

    public void SwapLines(int fromLine, int toLine)
    {
        Object.SwapLines(fromLine, toLine);
    }

    public void InsertLineAt(int line, string text)
    {
        Object.InsertLineAt(line, text);
    }

    public void RemoveLineAt(int line, bool moveCaretsDown = true)
    {
        Object.RemoveLineAt(line, moveCaretsDown);
    }

    public void InsertTextAtCaret(string text, int caretIndex = -1)
    {
        Object.InsertTextAtCaret(text, caretIndex);
    }

    public void InsertText(string text, int line, int column, bool beforeSelectionBegin = true,
        bool beforeSelectionEnd = false)
    {
        Object.InsertText(text, line, column, beforeSelectionBegin, beforeSelectionEnd);
    }

    public void RemoveText(int fromLine, int fromColumn, int toLine, int toColumn)
    {
        Object.RemoveText(fromLine, fromColumn, toLine, toColumn);
    }

    public int GetLastUnhiddenLine()
    {
        return Object.GetLastUnhiddenLine();
    }

    public int GetNextVisibleLineOffsetFrom(int line, int visibleAmount)
    {
        return Object.GetNextVisibleLineOffsetFrom(line, visibleAmount);
    }

    public Vector2I GetNextVisibleLineIndexOffsetFrom(int line, int wrapIndex, int visibleAmount)
    {
        return Object.GetNextVisibleLineIndexOffsetFrom(line, wrapIndex, visibleAmount);
    }

    public void Backspace(int caretIndex = -1)
    {
        Object.Backspace(caretIndex);
    }

    public void Cut(int caretIndex = -1)
    {
        Object.Cut(caretIndex);
    }

    public void Copy(int caretIndex = -1)
    {
        Object.Copy(caretIndex);
    }

    public void Paste(int caretIndex = -1)
    {
        Object.Paste(caretIndex);
    }

    public void PastePrimaryClipboard(int caretIndex = -1)
    {
        Object.PastePrimaryClipboard(caretIndex);
    }

    public void StartAction(TextEdit.EditAction action)
    {
        Object.StartAction(action);
    }

    public void EndAction()
    {
        Object.EndAction();
    }

    public void BeginComplexOperation()
    {
        Object.BeginComplexOperation();
    }

    public void EndComplexOperation()
    {
        Object.EndComplexOperation();
    }

    public bool HasUndo()
    {
        return Object.HasUndo();
    }

    public bool HasRedo()
    {
        return Object.HasRedo();
    }

    public void Undo()
    {
        Object.Undo();
    }

    public void Redo()
    {
        Object.Redo();
    }

    public void ClearUndoHistory()
    {
        Object.ClearUndoHistory();
    }

    public void TagSavedVersion()
    {
        Object.TagSavedVersion();
    }

    public uint GetVersion()
    {
        return Object.GetVersion();
    }

    public uint GetSavedVersion()
    {
        return Object.GetSavedVersion();
    }

    public void SetSearchText(string searchText)
    {
        Object.SetSearchText(searchText);
    }

    public void SetSearchFlags(uint flags)
    {
        Object.SetSearchFlags(flags);
    }

    public Vector2I Search(string text, uint flags, int fromLine, int fromColumn)
    {
        return Object.Search(text, flags, fromLine, fromColumn);
    }

    public void SetTooltipRequestFunc(Callable callback)
    {
        Object.SetTooltipRequestFunc(callback);
    }

    public Vector2 GetLocalMousePos()
    {
        return Object.GetLocalMousePos();
    }

    public string GetWordAtPos(Vector2 position)
    {
        return Object.GetWordAtPos(position);
    }

    public Vector2I GetLineColumnAtPos(Vector2I position, bool clampLine = true, bool clampColumn = true)
    {
        return Object.GetLineColumnAtPos(position, clampLine, clampColumn);
    }

    public Vector2I GetPosAtLineColumn(int line, int column)
    {
        return Object.GetPosAtLineColumn(line, column);
    }

    public Rect2I GetRectAtLineColumn(int line, int column)
    {
        return Object.GetRectAtLineColumn(line, column);
    }

    public int GetMinimapLineAtPos(Vector2I position)
    {
        return Object.GetMinimapLineAtPos(position);
    }

    public bool IsDraggingCursor()
    {
        return Object.IsDraggingCursor();
    }

    public bool IsMouseOverSelection(bool edges, int caretIndex = -1)
    {
        return Object.IsMouseOverSelection(edges, caretIndex);
    }

    public void SetCaretType(TextEdit.CaretTypeEnum type)
    {
        Object.SetCaretType(type);
    }

    public TextEdit.CaretTypeEnum GetCaretType()
    {
        return Object.GetCaretType();
    }

    public void SetCaretBlinkEnabled(bool enable)
    {
        Object.SetCaretBlinkEnabled(enable);
    }

    public bool IsCaretBlinkEnabled()
    {
        return Object.IsCaretBlinkEnabled();
    }

    public void SetCaretBlinkInterval(float interval)
    {
        Object.SetCaretBlinkInterval(interval);
    }

    public float GetCaretBlinkInterval()
    {
        return Object.GetCaretBlinkInterval();
    }

    public void SetDrawCaretWhenEditableDisabled(bool enable)
    {
        Object.SetDrawCaretWhenEditableDisabled(enable);
    }

    public bool IsDrawingCaretWhenEditableDisabled()
    {
        return Object.IsDrawingCaretWhenEditableDisabled();
    }

    public void SetMoveCaretOnRightClickEnabled(bool enable)
    {
        Object.SetMoveCaretOnRightClickEnabled(enable);
    }

    public bool IsMoveCaretOnRightClickEnabled()
    {
        return Object.IsMoveCaretOnRightClickEnabled();
    }

    public void SetCaretMidGraphemeEnabled(bool enabled)
    {
        Object.SetCaretMidGraphemeEnabled(enabled);
    }

    public bool IsCaretMidGraphemeEnabled()
    {
        return Object.IsCaretMidGraphemeEnabled();
    }

    public void SetMultipleCaretsEnabled(bool enabled)
    {
        Object.SetMultipleCaretsEnabled(enabled);
    }

    public bool IsMultipleCaretsEnabled()
    {
        return Object.IsMultipleCaretsEnabled();
    }

    public int AddCaret(int line, int column)
    {
        return Object.AddCaret(line, column);
    }

    public void RemoveCaret(int caret)
    {
        Object.RemoveCaret(caret);
    }

    public void RemoveSecondaryCarets()
    {
        Object.RemoveSecondaryCarets();
    }

    public int GetCaretCount()
    {
        return Object.GetCaretCount();
    }

    public void AddCaretAtCarets(bool below)
    {
        Object.AddCaretAtCarets(below);
    }

    public int[] GetSortedCarets(bool includeIgnoredCarets = false)
    {
        return Object.GetSortedCarets(includeIgnoredCarets);
    }

    public void CollapseCarets(int fromLine, int fromColumn, int toLine, int toColumn, bool inclusive = false)
    {
        Object.CollapseCarets(fromLine, fromColumn, toLine, toColumn, inclusive);
    }

    public void MergeOverlappingCarets()
    {
        Object.MergeOverlappingCarets();
    }

    public void BeginMulticaretEdit()
    {
        Object.BeginMulticaretEdit();
    }

    public void EndMulticaretEdit()
    {
        Object.EndMulticaretEdit();
    }

    public bool IsInMulitcaretEdit()
    {
        return Object.IsInMulitcaretEdit();
    }

    public bool MulticaretEditIgnoreCaret(int caretIndex)
    {
        return Object.MulticaretEditIgnoreCaret(caretIndex);
    }

    public bool IsCaretVisible(int caretIndex = 0)
    {
        return Object.IsCaretVisible(caretIndex);
    }

    public Vector2 GetCaretDrawPos(int caretIndex = 0)
    {
        return Object.GetCaretDrawPos(caretIndex);
    }

    public void SetCaretLine(int line, bool adjustViewport = true, bool canBeHidden = true, int wrapIndex = 0,
        int caretIndex = 0)
    {
        Object.SetCaretLine(line, adjustViewport, canBeHidden, wrapIndex, caretIndex);
    }

    public int GetCaretLine(int caretIndex = 0)
    {
        return Object.GetCaretLine(caretIndex);
    }

    public void SetCaretColumn(int column, bool adjustViewport = true, int caretIndex = 0)
    {
        Object.SetCaretColumn(column, adjustViewport, caretIndex);
    }

    public int GetCaretColumn(int caretIndex = 0)
    {
        return Object.GetCaretColumn(caretIndex);
    }

    public int GetNextCompositeCharacterColumn(int line, int column)
    {
        return Object.GetNextCompositeCharacterColumn(line, column);
    }

    public int GetPreviousCompositeCharacterColumn(int line, int column)
    {
        return Object.GetPreviousCompositeCharacterColumn(line, column);
    }

    public int GetCaretWrapIndex(int caretIndex = 0)
    {
        return Object.GetCaretWrapIndex(caretIndex);
    }

    public string GetWordUnderCaret(int caretIndex = -1)
    {
        return Object.GetWordUnderCaret(caretIndex);
    }

    public void SetUseDefaultWordSeparators(bool enabled)
    {
        Object.SetUseDefaultWordSeparators(enabled);
    }

    public bool IsDefaultWordSeparatorsEnabled()
    {
        return Object.IsDefaultWordSeparatorsEnabled();
    }

    public void SetUseCustomWordSeparators(bool enabled)
    {
        Object.SetUseCustomWordSeparators(enabled);
    }

    public bool IsCustomWordSeparatorsEnabled()
    {
        return Object.IsCustomWordSeparatorsEnabled();
    }

    public void SetCustomWordSeparators(string customWordSeparators)
    {
        Object.SetCustomWordSeparators(customWordSeparators);
    }

    public string GetCustomWordSeparators()
    {
        return Object.GetCustomWordSeparators();
    }

    public void SetSelectingEnabled(bool enable)
    {
        Object.SetSelectingEnabled(enable);
    }

    public bool IsSelectingEnabled()
    {
        return Object.IsSelectingEnabled();
    }

    public void SetDeselectOnFocusLossEnabled(bool enable)
    {
        Object.SetDeselectOnFocusLossEnabled(enable);
    }

    public bool IsDeselectOnFocusLossEnabled()
    {
        return Object.IsDeselectOnFocusLossEnabled();
    }

    public void SetDragAndDropSelectionEnabled(bool enable)
    {
        Object.SetDragAndDropSelectionEnabled(enable);
    }

    public bool IsDragAndDropSelectionEnabled()
    {
        return Object.IsDragAndDropSelectionEnabled();
    }

    public void SetSelectionMode(TextEdit.SelectionMode mode)
    {
        Object.SetSelectionMode(mode);
    }

    public TextEdit.SelectionMode GetSelectionMode()
    {
        return Object.GetSelectionMode();
    }

    public void SelectAll()
    {
        Object.SelectAll();
    }

    public void SelectWordUnderCaret(int caretIndex = -1)
    {
        Object.SelectWordUnderCaret(caretIndex);
    }

    public void AddSelectionForNextOccurrence()
    {
        Object.AddSelectionForNextOccurrence();
    }

    public void SkipSelectionForNextOccurrence()
    {
        Object.SkipSelectionForNextOccurrence();
    }

    public void Select(int originLine, int originColumn, int caretLine, int caretColumn, int caretIndex = 0)
    {
        Object.Select(originLine, originColumn, caretLine, caretColumn, caretIndex);
    }

    public bool HasSelection(int caretIndex = -1)
    {
        return Object.HasSelection(caretIndex);
    }

    public string GetSelectedText(int caretIndex = -1)
    {
        return Object.GetSelectedText(caretIndex);
    }

    public int GetSelectionAtLineColumn(int line, int column, bool includeEdges = true,
        bool onlySelections = true)
    {
        return Object.GetSelectionAtLineColumn(line, column, includeEdges, onlySelections);
    }

    public Array<Vector2I> GetLineRangesFromCarets(bool onlySelections = false,
        bool mergeAdjacent = true)
    {
        return Object.GetLineRangesFromCarets(onlySelections, mergeAdjacent);
    }

    public int GetSelectionOriginLine(int caretIndex = 0)
    {
        return Object.GetSelectionOriginLine(caretIndex);
    }

    public int GetSelectionOriginColumn(int caretIndex = 0)
    {
        return Object.GetSelectionOriginColumn(caretIndex);
    }

    public void SetSelectionOriginLine(int line, bool canBeHidden = true, int wrapIndex = -1,
        int caretIndex = 0)
    {
        Object.SetSelectionOriginLine(line, canBeHidden, wrapIndex, caretIndex);
    }

    public void SetSelectionOriginColumn(int column, int caretIndex = 0)
    {
        Object.SetSelectionOriginColumn(column, caretIndex);
    }

    public int GetSelectionFromLine(int caretIndex = 0)
    {
        return Object.GetSelectionFromLine(caretIndex);
    }

    public int GetSelectionFromColumn(int caretIndex = 0)
    {
        return Object.GetSelectionFromColumn(caretIndex);
    }

    public int GetSelectionToLine(int caretIndex = 0)
    {
        return Object.GetSelectionToLine(caretIndex);
    }

    public int GetSelectionToColumn(int caretIndex = 0)
    {
        return Object.GetSelectionToColumn(caretIndex);
    }

    public bool IsCaretAfterSelectionOrigin(int caretIndex = 0)
    {
        return Object.IsCaretAfterSelectionOrigin(caretIndex);
    }

    public void Deselect(int caretIndex = -1)
    {
        Object.Deselect(caretIndex);
    }

    public void DeleteSelection(int caretIndex = -1)
    {
        Object.DeleteSelection(caretIndex);
    }

    public void SetLineWrappingMode(TextEdit.LineWrappingMode mode)
    {
        Object.SetLineWrappingMode(mode);
    }

    public TextEdit.LineWrappingMode GetLineWrappingMode()
    {
        return Object.GetLineWrappingMode();
    }

    public void SetAutowrapMode(TextServer.AutowrapMode autowrapMode)
    {
        Object.SetAutowrapMode(autowrapMode);
    }

    public TextServer.AutowrapMode GetAutowrapMode()
    {
        return Object.GetAutowrapMode();
    }

    public bool IsLineWrapped(int line)
    {
        return Object.IsLineWrapped(line);
    }

    public int GetLineWrapCount(int line)
    {
        return Object.GetLineWrapCount(line);
    }

    public int GetLineWrapIndexAtColumn(int line, int column)
    {
        return Object.GetLineWrapIndexAtColumn(line, column);
    }

    public string[] GetLineWrappedText(int line)
    {
        return Object.GetLineWrappedText(line);
    }

    public void SetSmoothScrollEnabled(bool enable)
    {
        Object.SetSmoothScrollEnabled(enable);
    }

    public bool IsSmoothScrollEnabled()
    {
        return Object.IsSmoothScrollEnabled();
    }

    public VScrollBar GetVScrollBar()
    {
        return Object.GetVScrollBar();
    }

    public HScrollBar GetHScrollBar()
    {
        return Object.GetHScrollBar();
    }

    public void SetVScroll(float value)
    {
        Object.SetVScroll(value);
    }

    public double GetVScroll()
    {
        return Object.GetVScroll();
    }

    public void SetHScroll(int value)
    {
        Object.SetHScroll(value);
    }

    public int GetHScroll()
    {
        return Object.GetHScroll();
    }

    public void SetScrollPastEndOfFileEnabled(bool enable)
    {
        Object.SetScrollPastEndOfFileEnabled(enable);
    }

    public bool IsScrollPastEndOfFileEnabled()
    {
        return Object.IsScrollPastEndOfFileEnabled();
    }

    public void SetVScrollSpeed(float speed)
    {
        Object.SetVScrollSpeed(speed);
    }

    public float GetVScrollSpeed()
    {
        return Object.GetVScrollSpeed();
    }

    public void SetFitContentHeightEnabled(bool enabled)
    {
        Object.SetFitContentHeightEnabled(enabled);
    }

    public bool IsFitContentHeightEnabled()
    {
        return Object.IsFitContentHeightEnabled();
    }

    public void SetFitContentWidthEnabled(bool enabled)
    {
        Object.SetFitContentWidthEnabled(enabled);
    }

    public bool IsFitContentWidthEnabled()
    {
        return Object.IsFitContentWidthEnabled();
    }

    public double GetScrollPosForLine(int line, int wrapIndex = 0)
    {
        return Object.GetScrollPosForLine(line, wrapIndex);
    }

    public void SetLineAsFirstVisible(int line, int wrapIndex = 0)
    {
        Object.SetLineAsFirstVisible(line, wrapIndex);
    }

    public int GetFirstVisibleLine()
    {
        return Object.GetFirstVisibleLine();
    }

    public void SetLineAsCenterVisible(int line, int wrapIndex = 0)
    {
        Object.SetLineAsCenterVisible(line, wrapIndex);
    }

    public void SetLineAsLastVisible(int line, int wrapIndex = 0)
    {
        Object.SetLineAsLastVisible(line, wrapIndex);
    }

    public int GetLastFullVisibleLine()
    {
        return Object.GetLastFullVisibleLine();
    }

    public int GetLastFullVisibleLineWrapIndex()
    {
        return Object.GetLastFullVisibleLineWrapIndex();
    }

    public int GetVisibleLineCount()
    {
        return Object.GetVisibleLineCount();
    }

    public int GetVisibleLineCountInRange(int fromLine, int toLine)
    {
        return Object.GetVisibleLineCountInRange(fromLine, toLine);
    }

    public int GetTotalVisibleLineCount()
    {
        return Object.GetTotalVisibleLineCount();
    }

    public void AdjustViewportToCaret(int caretIndex = 0)
    {
        Object.AdjustViewportToCaret(caretIndex);
    }

    public void CenterViewportToCaret(int caretIndex = 0)
    {
        Object.CenterViewportToCaret(caretIndex);
    }

    public void SetDrawMinimap(bool enabled)
    {
        Object.SetDrawMinimap(enabled);
    }

    public bool IsDrawingMinimap()
    {
        return Object.IsDrawingMinimap();
    }

    public void SetMinimapWidth(int width)
    {
        Object.SetMinimapWidth(width);
    }

    public int GetMinimapWidth()
    {
        return Object.GetMinimapWidth();
    }

    public int GetMinimapVisibleLines()
    {
        return Object.GetMinimapVisibleLines();
    }

    public void AddGutter(int at = -1)
    {
        Object.AddGutter(at);
    }

    public void RemoveGutter(int gutter)
    {
        Object.RemoveGutter(gutter);
    }

    public int GetGutterCount()
    {
        return Object.GetGutterCount();
    }

    public void SetGutterName(int gutter, string name)
    {
        Object.SetGutterName(gutter, name);
    }

    public string GetGutterName(int gutter)
    {
        return Object.GetGutterName(gutter);
    }

    public void SetGutterType(int gutter, TextEdit.GutterType type)
    {
        Object.SetGutterType(gutter, type);
    }

    public TextEdit.GutterType GetGutterType(int gutter)
    {
        return Object.GetGutterType(gutter);
    }

    public void SetGutterWidth(int gutter, int width)
    {
        Object.SetGutterWidth(gutter, width);
    }

    public int GetGutterWidth(int gutter)
    {
        return Object.GetGutterWidth(gutter);
    }

    public void SetGutterDraw(int gutter, bool draw)
    {
        Object.SetGutterDraw(gutter, draw);
    }

    public bool IsGutterDrawn(int gutter)
    {
        return Object.IsGutterDrawn(gutter);
    }

    public void SetGutterClickable(int gutter, bool clickable)
    {
        Object.SetGutterClickable(gutter, clickable);
    }

    public bool IsGutterClickable(int gutter)
    {
        return Object.IsGutterClickable(gutter);
    }

    public void SetGutterOverwritable(int gutter, bool overwritable)
    {
        Object.SetGutterOverwritable(gutter, overwritable);
    }

    public bool IsGutterOverwritable(int gutter)
    {
        return Object.IsGutterOverwritable(gutter);
    }

    public void MergeGutters(int fromLine, int toLine)
    {
        Object.MergeGutters(fromLine, toLine);
    }

    public void SetGutterCustomDraw(int column, Callable drawCallback)
    {
        Object.SetGutterCustomDraw(column, drawCallback);
    }

    public int GetTotalGutterWidth()
    {
        return Object.GetTotalGutterWidth();
    }

    public void SetLineGutterMetadata(int line, int gutter, Variant metadata)
    {
        Object.SetLineGutterMetadata(line, gutter, metadata);
    }

    public Variant GetLineGutterMetadata(int line, int gutter)
    {
        return Object.GetLineGutterMetadata(line, gutter);
    }

    public void SetLineGutterText(int line, int gutter, string text)
    {
        Object.SetLineGutterText(line, gutter, text);
    }

    public string GetLineGutterText(int line, int gutter)
    {
        return Object.GetLineGutterText(line, gutter);
    }

    public void SetLineGutterIcon(int line, int gutter, Texture2D icon)
    {
        Object.SetLineGutterIcon(line, gutter, icon);
    }

    public Texture2D GetLineGutterIcon(int line, int gutter)
    {
        return Object.GetLineGutterIcon(line, gutter);
    }

    public void SetLineGutterItemColor(int line, int gutter, Color color)
    {
        Object.SetLineGutterItemColor(line, gutter, color);
    }

    public Color GetLineGutterItemColor(int line, int gutter)
    {
        return Object.GetLineGutterItemColor(line, gutter);
    }

    public void SetLineGutterClickable(int line, int gutter, bool clickable)
    {
        Object.SetLineGutterClickable(line, gutter, clickable);
    }

    public bool IsLineGutterClickable(int line, int gutter)
    {
        return Object.IsLineGutterClickable(line, gutter);
    }

    public void SetLineBackgroundColor(int line, Color color)
    {
        Object.SetLineBackgroundColor(line, color);
    }

    public Color GetLineBackgroundColor(int line)
    {
        return Object.GetLineBackgroundColor(line);
    }

    public void SetSyntaxHighlighter(SyntaxHighlighter syntaxHighlighter)
    {
        Object.SetSyntaxHighlighter(syntaxHighlighter);
    }

    public SyntaxHighlighter GetSyntaxHighlighter()
    {
        return Object.GetSyntaxHighlighter();
    }

    public void SetHighlightCurrentLine(bool enabled)
    {
        Object.SetHighlightCurrentLine(enabled);
    }

    public bool IsHighlightCurrentLineEnabled()
    {
        return Object.IsHighlightCurrentLineEnabled();
    }

    public void SetHighlightAllOccurrences(bool enabled)
    {
        Object.SetHighlightAllOccurrences(enabled);
    }

    public bool IsHighlightAllOccurrencesEnabled()
    {
        return Object.IsHighlightAllOccurrencesEnabled();
    }

    public bool GetDrawControlChars()
    {
        return Object.GetDrawControlChars();
    }

    public void SetDrawControlChars(bool enabled)
    {
        Object.SetDrawControlChars(enabled);
    }

    public void SetDrawTabs(bool enabled)
    {
        Object.SetDrawTabs(enabled);
    }

    public bool IsDrawingTabs()
    {
        return Object.IsDrawingTabs();
    }

    public void SetDrawSpaces(bool enabled)
    {
        Object.SetDrawSpaces(enabled);
    }

    public bool IsDrawingSpaces()
    {
        return Object.IsDrawingSpaces();
    }

    public PopupMenu GetMenu()
    {
        return Object.GetMenu();
    }

    public bool IsMenuVisible()
    {
        return Object.IsMenuVisible();
    }

    public void MenuOption(int option)
    {
        Object.MenuOption(option);
    }

    [Obsolete("No longer necessary since methods now adjust carets themselves.")]
    public void AdjustCaretsAfterEdit(int caret, int fromLine, int fromCol, int toLine, int toCol)
    {
        Object.AdjustCaretsAfterEdit(caret, fromLine, fromCol, toLine, toCol);
    }

    [Obsolete(
        "Carets no longer need to be edited in any specific order. If the carets need to be sorted, use 'Godot.TextEdit.GetSortedCarets(bool)' instead.")]
    public int[] GetCaretIndexEditOrder()
    {
        return Object.GetCaretIndexEditOrder();
    }

    [Obsolete("Use 'Godot.TextEdit.GetSelectionOriginLine(int)' instead.")]
    public int GetSelectionLine(int caretIndex = 0)
    {
        return Object.GetSelectionLine(caretIndex);
    }

    [Obsolete("Use 'Godot.TextEdit.GetSelectionOriginColumn(int)' instead.")]
    public int GetSelectionColumn(int caretIndex = 0)
    {
        return Object.GetSelectionColumn(caretIndex);
    }

    public void AcceptEvent()
    {
        Object.AcceptEvent();
    }

    public Vector2 GetMinimumSize()
    {
        return Object.GetMinimumSize();
    }

    public Vector2 GetCombinedMinimumSize()
    {
        return Object.GetCombinedMinimumSize();
    }

    public void SetAnchorsPreset(Control.LayoutPreset preset, bool keepOffsets = false)
    {
        Object.SetAnchorsPreset(preset, keepOffsets);
    }

    public void SetOffsetsPreset(Control.LayoutPreset preset, Control.LayoutPresetMode resizeMode = 0,
        int margin = 0)
    {
        Object.SetOffsetsPreset(preset, resizeMode, margin);
    }

    public void SetAnchorsAndOffsetsPreset(Control.LayoutPreset preset, Control.LayoutPresetMode resizeMode = 0,
        int margin = 0)
    {
        Object.SetAnchorsAndOffsetsPreset(preset, resizeMode, margin);
    }

    public void SetAnchor(Side side, float anchor, bool keepOffset = false, bool pushOppositeAnchor = true)
    {
        Object.SetAnchor(side, anchor, keepOffset, pushOppositeAnchor);
    }

    public float GetAnchor(Side side)
    {
        return Object.GetAnchor(side);
    }

    public void SetOffset(Side side, float offset)
    {
        Object.SetOffset(side, offset);
    }

    public float GetOffset(Side offset)
    {
        return Object.GetOffset(offset);
    }

    public void SetAnchorAndOffset(Side side, float anchor, float offset, bool pushOppositeAnchor = false)
    {
        Object.SetAnchorAndOffset(side, anchor, offset, pushOppositeAnchor);
    }

    public void SetBegin(Vector2 position)
    {
        Object.SetBegin(position);
    }

    public void SetEnd(Vector2 position)
    {
        Object.SetEnd(position);
    }

    public void SetPosition(Vector2 position, bool keepOffsets = false)
    {
        Object.SetPosition(position, keepOffsets);
    }

    public void SetSize(Vector2 size, bool keepOffsets = false)
    {
        Object.SetSize(size, keepOffsets);
    }

    public void ResetSize()
    {
        Object.ResetSize();
    }

    public void SetCustomMinimumSize(Vector2 size)
    {
        Object.SetCustomMinimumSize(size);
    }

    public void SetGlobalPosition(Vector2 position, bool keepOffsets = false)
    {
        Object.SetGlobalPosition(position, keepOffsets);
    }

    public void SetRotation(float radians)
    {
        Object.SetRotation(radians);
    }

    public void SetRotationDegrees(float degrees)
    {
        Object.SetRotationDegrees(degrees);
    }

    public void SetScale(Vector2 scale)
    {
        Object.SetScale(scale);
    }

    public void SetPivotOffset(Vector2 pivotOffset)
    {
        Object.SetPivotOffset(pivotOffset);
    }

    public Vector2 GetBegin()
    {
        return Object.GetBegin();
    }

    public Vector2 GetEnd()
    {
        return Object.GetEnd();
    }

    public Vector2 GetPosition()
    {
        return Object.GetPosition();
    }

    public Vector2 GetSize()
    {
        return Object.GetSize();
    }

    public float GetRotation()
    {
        return Object.GetRotation();
    }

    public float GetRotationDegrees()
    {
        return Object.GetRotationDegrees();
    }

    public Vector2 GetScale()
    {
        return Object.GetScale();
    }

    public Vector2 GetPivotOffset()
    {
        return Object.GetPivotOffset();
    }

    public Vector2 GetCustomMinimumSize()
    {
        return Object.GetCustomMinimumSize();
    }

    public Vector2 GetParentAreaSize()
    {
        return Object.GetParentAreaSize();
    }

    public Vector2 GetGlobalPosition()
    {
        return Object.GetGlobalPosition();
    }

    public Vector2 GetScreenPosition()
    {
        return Object.GetScreenPosition();
    }

    public Rect2 GetRect()
    {
        return Object.GetRect();
    }

    public Rect2 GetGlobalRect()
    {
        return Object.GetGlobalRect();
    }

    public void SetFocusMode(Control.FocusModeEnum mode)
    {
        Object.SetFocusMode(mode);
    }

    public Control.FocusModeEnum GetFocusMode()
    {
        return Object.GetFocusMode();
    }

    public Control.FocusModeEnum GetFocusModeWithOverride()
    {
        return Object.GetFocusModeWithOverride();
    }

    public void SetFocusBehaviorRecursive(Control.FocusBehaviorRecursiveEnum focusBehaviorRecursive)
    {
        Object.SetFocusBehaviorRecursive(focusBehaviorRecursive);
    }

    public Control.FocusBehaviorRecursiveEnum GetFocusBehaviorRecursive()
    {
        return Object.GetFocusBehaviorRecursive();
    }

    public bool HasFocus()
    {
        return Object.HasFocus();
    }

    public void GrabFocus()
    {
        Object.GrabFocus();
    }

    public void ReleaseFocus()
    {
        Object.ReleaseFocus();
    }

    public Control FindPrevValidFocus()
    {
        return Object.FindPrevValidFocus();
    }

    public Control FindNextValidFocus()
    {
        return Object.FindNextValidFocus();
    }

    public Control FindValidFocusNeighbor(Side side)
    {
        return Object.FindValidFocusNeighbor(side);
    }

    public void SetHSizeFlags(Control.SizeFlags flags)
    {
        Object.SetHSizeFlags(flags);
    }

    public Control.SizeFlags GetHSizeFlags()
    {
        return Object.GetHSizeFlags();
    }

    public void SetStretchRatio(float ratio)
    {
        Object.SetStretchRatio(ratio);
    }

    public float GetStretchRatio()
    {
        return Object.GetStretchRatio();
    }

    public void SetVSizeFlags(Control.SizeFlags flags)
    {
        Object.SetVSizeFlags(flags);
    }

    public Control.SizeFlags GetVSizeFlags()
    {
        return Object.GetVSizeFlags();
    }

    public void SetTheme(Theme theme)
    {
        Object.SetTheme(theme);
    }

    public Theme GetTheme()
    {
        return Object.GetTheme();
    }

    public void SetThemeTypeVariation(StringName themeType)
    {
        Object.SetThemeTypeVariation(themeType);
    }

    public StringName GetThemeTypeVariation()
    {
        return Object.GetThemeTypeVariation();
    }

    public void BeginBulkThemeOverride()
    {
        Object.BeginBulkThemeOverride();
    }

    public void EndBulkThemeOverride()
    {
        Object.EndBulkThemeOverride();
    }

    public void AddThemeIconOverride(StringName name, Texture2D texture)
    {
        Object.AddThemeIconOverride(name, texture);
    }

    public void AddThemeStyleboxOverride(StringName name, StyleBox stylebox)
    {
        Object.AddThemeStyleboxOverride(name, stylebox);
    }

    public void AddThemeFontOverride(StringName name, Font font)
    {
        Object.AddThemeFontOverride(name, font);
    }

    public void AddThemeFontSizeOverride(StringName name, int fontSize)
    {
        Object.AddThemeFontSizeOverride(name, fontSize);
    }

    public void AddThemeColorOverride(StringName name, Color color)
    {
        Object.AddThemeColorOverride(name, color);
    }

    public void AddThemeConstantOverride(StringName name, int constant)
    {
        Object.AddThemeConstantOverride(name, constant);
    }

    public void RemoveThemeIconOverride(StringName name)
    {
        Object.RemoveThemeIconOverride(name);
    }

    public void RemoveThemeStyleboxOverride(StringName name)
    {
        Object.RemoveThemeStyleboxOverride(name);
    }

    public void RemoveThemeFontOverride(StringName name)
    {
        Object.RemoveThemeFontOverride(name);
    }

    public void RemoveThemeFontSizeOverride(StringName name)
    {
        Object.RemoveThemeFontSizeOverride(name);
    }

    public void RemoveThemeColorOverride(StringName name)
    {
        Object.RemoveThemeColorOverride(name);
    }

    public void RemoveThemeConstantOverride(StringName name)
    {
        Object.RemoveThemeConstantOverride(name);
    }

    public Texture2D GetThemeIcon(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeIcon(name, themeType);
    }

    public StyleBox GetThemeStylebox(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeStylebox(name, themeType);
    }

    public Font GetThemeFont(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeFont(name, themeType);
    }

    public int GetThemeFontSize(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeFontSize(name, themeType);
    }

    public Color GetThemeColor(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeColor(name, themeType);
    }

    public int GetThemeConstant(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.GetThemeConstant(name, themeType);
    }

    public bool HasThemeIconOverride(StringName name)
    {
        return Object.HasThemeIconOverride(name);
    }

    public bool HasThemeStyleboxOverride(StringName name)
    {
        return Object.HasThemeStyleboxOverride(name);
    }

    public bool HasThemeFontOverride(StringName name)
    {
        return Object.HasThemeFontOverride(name);
    }

    public bool HasThemeFontSizeOverride(StringName name)
    {
        return Object.HasThemeFontSizeOverride(name);
    }

    public bool HasThemeColorOverride(StringName name)
    {
        return Object.HasThemeColorOverride(name);
    }

    public bool HasThemeConstantOverride(StringName name)
    {
        return Object.HasThemeConstantOverride(name);
    }

    public bool HasThemeIcon(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeIcon(name, themeType);
    }

    public bool HasThemeStylebox(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeStylebox(name, themeType);
    }

    public bool HasThemeFont(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeFont(name, themeType);
    }

    public bool HasThemeFontSize(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeFontSize(name, themeType);
    }

    public bool HasThemeColor(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeColor(name, themeType);
    }

    public bool HasThemeConstant(StringName name, StringName? themeType = null)
    {
        themeType ??= "";
        return Object.HasThemeConstant(name, themeType);
    }

    public float GetThemeDefaultBaseScale()
    {
        return Object.GetThemeDefaultBaseScale();
    }

    public Font GetThemeDefaultFont()
    {
        return Object.GetThemeDefaultFont();
    }

    public int GetThemeDefaultFontSize()
    {
        return Object.GetThemeDefaultFontSize();
    }

    public Control GetParentControl()
    {
        return Object.GetParentControl();
    }

    public void SetHGrowDirection(Control.GrowDirection direction)
    {
        Object.SetHGrowDirection(direction);
    }

    public Control.GrowDirection GetHGrowDirection()
    {
        return Object.GetHGrowDirection();
    }

    public void SetVGrowDirection(Control.GrowDirection direction)
    {
        Object.SetVGrowDirection(direction);
    }

    public Control.GrowDirection GetVGrowDirection()
    {
        return Object.GetVGrowDirection();
    }

    public void SetTooltipAutoTranslateMode(Node.AutoTranslateModeEnum mode)
    {
        Object.SetTooltipAutoTranslateMode(mode);
    }

    public Node.AutoTranslateModeEnum GetTooltipAutoTranslateMode()
    {
        return Object.GetTooltipAutoTranslateMode();
    }

    public void SetTooltipText(string hint)
    {
        Object.SetTooltipText(hint);
    }

    public string GetTooltipText()
    {
        return Object.GetTooltipText();
    }

    public string GetTooltip(Vector2? atPosition = null)
    {
        atPosition ??= new Vector2(0.0f, 0.0f);
        return Object.GetTooltip(atPosition);
    }

    public void SetDefaultCursorShape(Control.CursorShape shape)
    {
        Object.SetDefaultCursorShape(shape);
    }

    public Control.CursorShape GetDefaultCursorShape()
    {
        return Object.GetDefaultCursorShape();
    }

    public Control.CursorShape GetCursorShape(Vector2? position = null)
    {
        position ??= new Vector2(0.0f, 0.0f);
        return Object.GetCursorShape(position);
    }

    public void SetFocusNeighbor(Side side, NodePath neighbor)
    {
        Object.SetFocusNeighbor(side, neighbor);
    }

    public NodePath GetFocusNeighbor(Side side)
    {
        return Object.GetFocusNeighbor(side);
    }

    public void SetFocusNext(NodePath next)
    {
        Object.SetFocusNext(next);
    }

    public NodePath GetFocusNext()
    {
        return Object.GetFocusNext();
    }

    public void SetFocusPrevious(NodePath previous)
    {
        Object.SetFocusPrevious(previous);
    }

    public NodePath GetFocusPrevious()
    {
        return Object.GetFocusPrevious();
    }

    public void ForceDrag(Variant data, Control preview)
    {
        Object.ForceDrag(data, preview);
    }

    public void AccessibilityDrag()
    {
        Object.AccessibilityDrag();
    }

    public void AccessibilityDrop()
    {
        Object.AccessibilityDrop();
    }

    public void SetAccessibilityName(string name)
    {
        Object.SetAccessibilityName(name);
    }

    public string GetAccessibilityName()
    {
        return Object.GetAccessibilityName();
    }

    public void SetAccessibilityDescription(string description)
    {
        Object.SetAccessibilityDescription(description);
    }

    public string GetAccessibilityDescription()
    {
        return Object.GetAccessibilityDescription();
    }

    public void SetAccessibilityLive(DisplayServer.AccessibilityLiveMode mode)
    {
        Object.SetAccessibilityLive(mode);
    }

    public DisplayServer.AccessibilityLiveMode GetAccessibilityLive()
    {
        return Object.GetAccessibilityLive();
    }

    public void SetAccessibilityControlsNodes(Array<NodePath> nodePath)
    {
        Object.SetAccessibilityControlsNodes(nodePath);
    }

    public Array<NodePath> GetAccessibilityControlsNodes()
    {
        return Object.GetAccessibilityControlsNodes();
    }

    public void SetAccessibilityDescribedByNodes(Array<NodePath> nodePath)
    {
        Object.SetAccessibilityDescribedByNodes(nodePath);
    }

    public Array<NodePath> GetAccessibilityDescribedByNodes()
    {
        return Object.GetAccessibilityDescribedByNodes();
    }

    public void SetAccessibilityLabeledByNodes(Array<NodePath> nodePath)
    {
        Object.SetAccessibilityLabeledByNodes(nodePath);
    }

    public Array<NodePath> GetAccessibilityLabeledByNodes()
    {
        return Object.GetAccessibilityLabeledByNodes();
    }

    public void SetAccessibilityFlowToNodes(Array<NodePath> nodePath)
    {
        Object.SetAccessibilityFlowToNodes(nodePath);
    }

    public Array<NodePath> GetAccessibilityFlowToNodes()
    {
        return Object.GetAccessibilityFlowToNodes();
    }

    public void SetMouseFilter(Control.MouseFilterEnum filter)
    {
        Object.SetMouseFilter(filter);
    }

    public Control.MouseFilterEnum GetMouseFilter()
    {
        return Object.GetMouseFilter();
    }

    public Control.MouseFilterEnum GetMouseFilterWithOverride()
    {
        return Object.GetMouseFilterWithOverride();
    }

    public void SetMouseBehaviorRecursive(Control.MouseBehaviorRecursiveEnum mouseBehaviorRecursive)
    {
        Object.SetMouseBehaviorRecursive(mouseBehaviorRecursive);
    }

    public Control.MouseBehaviorRecursiveEnum GetMouseBehaviorRecursive()
    {
        return Object.GetMouseBehaviorRecursive();
    }

    public void SetForcePassScrollEvents(bool forcePassScrollEvents)
    {
        Object.SetForcePassScrollEvents(forcePassScrollEvents);
    }

    public bool IsForcePassScrollEvents()
    {
        return Object.IsForcePassScrollEvents();
    }

    public void SetClipContents(bool enable)
    {
        Object.SetClipContents(enable);
    }

    public bool IsClippingContents()
    {
        return Object.IsClippingContents();
    }

    public void GrabClickFocus()
    {
        Object.GrabClickFocus();
    }

    public void SetDragForwarding(Callable dragFunc, Callable canDropFunc, Callable dropFunc)
    {
        Object.SetDragForwarding(dragFunc, canDropFunc, dropFunc);
    }

    public void SetDragPreview(Control control)
    {
        Object.SetDragPreview(control);
    }

    public bool IsDragSuccessful()
    {
        return Object.IsDragSuccessful();
    }

    public void WarpMouse(Vector2 position)
    {
        Object.WarpMouse(position);
    }

    public void SetShortcutContext(Node node)
    {
        Object.SetShortcutContext(node);
    }

    public Node GetShortcutContext()
    {
        return Object.GetShortcutContext();
    }

    public void UpdateMinimumSize()
    {
        Object.UpdateMinimumSize();
    }

    public void SetLayoutDirection(Control.LayoutDirectionEnum direction)
    {
        Object.SetLayoutDirection(direction);
    }

    public Control.LayoutDirectionEnum GetLayoutDirection()
    {
        return Object.GetLayoutDirection();
    }

    public bool IsLayoutRtl()
    {
        return Object.IsLayoutRtl();
    }

    public void SetAutoTranslate(bool enable)
    {
        Object.SetAutoTranslate(enable);
    }

    public bool IsAutoTranslating()
    {
        return Object.IsAutoTranslating();
    }

    public void SetLocalizeNumeralSystem(bool enable)
    {
        Object.SetLocalizeNumeralSystem(enable);
    }

    public bool IsLocalizingNumeralSystem()
    {
        return Object.IsLocalizingNumeralSystem();
    }

    public Rid GetCanvasItem()
    {
        return Object.GetCanvasItem();
    }

    public void SetVisible(bool visible)
    {
        Object.SetVisible(visible);
    }

    public bool IsVisible()
    {
        return Object.IsVisible();
    }

    public bool IsVisibleInTree()
    {
        return Object.IsVisibleInTree();
    }

    public void Show()
    {
        Object.Show();
    }

    public void Hide()
    {
        Object.Hide();
    }

    public void QueueRedraw()
    {
        Object.QueueRedraw();
    }

    public void MoveToFront()
    {
        Object.MoveToFront();
    }

    public void SetAsTopLevel(bool enable)
    {
        Object.SetAsTopLevel(enable);
    }

    public bool IsSetAsTopLevel()
    {
        return Object.IsSetAsTopLevel();
    }

    public void SetLightMask(int lightMask)
    {
        Object.SetLightMask(lightMask);
    }

    public int GetLightMask()
    {
        return Object.GetLightMask();
    }

    public void SetModulate(Color modulate)
    {
        Object.SetModulate(modulate);
    }

    public Color GetModulate()
    {
        return Object.GetModulate();
    }

    public void SetSelfModulate(Color selfModulate)
    {
        Object.SetSelfModulate(selfModulate);
    }

    public Color GetSelfModulate()
    {
        return Object.GetSelfModulate();
    }

    public void SetZIndex(int zIndex)
    {
        Object.SetZIndex(zIndex);
    }

    public int GetZIndex()
    {
        return Object.GetZIndex();
    }

    public void SetZAsRelative(bool enable)
    {
        Object.SetZAsRelative(enable);
    }

    public bool IsZRelative()
    {
        return Object.IsZRelative();
    }

    public void SetYSortEnabled(bool enabled)
    {
        Object.SetYSortEnabled(enabled);
    }

    public bool IsYSortEnabled()
    {
        return Object.IsYSortEnabled();
    }

    public void SetDrawBehindParent(bool enable)
    {
        Object.SetDrawBehindParent(enable);
    }

    public bool IsDrawBehindParentEnabled()
    {
        return Object.IsDrawBehindParentEnabled();
    }

    public void DrawLine(Vector2 from, Vector2 to, Color color, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawLine(from, to, color, width, antialiased);
    }

    public void DrawDashedLine(Vector2 from, Vector2 to, Color color, float width = -1.0f, float dash = 2.0f,
        bool aligned = true, bool antialiased = false)
    {
        Object.DrawDashedLine(from, to, color, width, dash, aligned, antialiased);
    }

    public void DrawPolyline(Vector2[] points, Color color, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawPolyline(points, color, width, antialiased);
    }

    public void DrawPolylineColors(Vector2[] points, Color[] colors, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawPolylineColors(points, colors, width, antialiased);
    }

    public void DrawArc(Vector2 center, float radius, float startAngle, float endAngle, int pointCount,
        Color color, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawArc(center, radius, startAngle, endAngle, pointCount, color, width, antialiased);
    }

    public void DrawMultiline(Vector2[] points, Color color, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawMultiline(points, color, width, antialiased);
    }

    public void DrawMultilineColors(Vector2[] points, Color[] colors, float width = -1.0f, bool antialiased = false)
    {
        Object.DrawMultilineColors(points, colors, width, antialiased);
    }

    public void DrawRect(Rect2 rect, Color color, bool filled = true, float width = -1.0f,
        bool antialiased = false)
    {
        Object.DrawRect(rect, color, filled, width, antialiased);
    }

    public void DrawCircle(Vector2 position, float radius, Color color, bool filled = true, float width = -1.0f,
        bool antialiased = false)
    {
        Object.DrawCircle(position, radius, color, filled, width, antialiased);
    }

    public void DrawTexture(Texture2D texture, Vector2 position, Color? modulate = null)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawTexture(texture, position, modulate);
    }

    public void DrawTextureRect(Texture2D texture, Rect2 rect, bool tile, Color? modulate = null,
        bool transpose = false)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawTextureRect(texture, rect, tile, modulate, transpose);
    }

    public void DrawTextureRectRegion(Texture2D texture, Rect2 rect, Rect2 srcRect, Color? modulate = null,
        bool transpose = false, bool clipUv = true)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawTextureRectRegion(texture, rect, srcRect, modulate, transpose, clipUv);
    }

    public void DrawMsdfTextureRectRegion(Texture2D texture, Rect2 rect, Rect2 srcRect, Color? modulate = null,
        float outline = 0.0f, float pixelRange = 4.0f, float scale = 1.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawMsdfTextureRectRegion(texture, rect, srcRect, modulate, outline, pixelRange, scale);
    }

    public void DrawLcdTextureRectRegion(Texture2D texture, Rect2 rect, Rect2 srcRect, Color? modulate = null)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawLcdTextureRectRegion(texture, rect, srcRect, modulate);
    }

    public void DrawStyleBox(StyleBox styleBox, Rect2 rect)
    {
        Object.DrawStyleBox(styleBox, rect);
    }

    public void DrawPrimitive(Vector2[] points, Color[] colors, Vector2[] uvs, Texture2D? texture = null)
    {
        Object.DrawPrimitive(points, colors, uvs, texture);
    }

    public void DrawPolygon(Vector2[] points, Color[] colors, Vector2[]? uvs = null, Texture2D? texture = null)
    {
        uvs ??= [];
        Object.DrawPolygon(points, colors, uvs, texture);
    }

    public void DrawColoredPolygon(Vector2[] points, Color color, Vector2[]? uvs = null, Texture2D? texture = null)
    {
        uvs ??= [];
        Object.DrawColoredPolygon(points, color, uvs, texture);
    }

    public void DrawString(Font font, Vector2 pos, string text, HorizontalAlignment alignment = 0,
        float width = -1, int fontSize = 16, Color? modulate = null,
        TextServer.JustificationFlag justificationFlags = (TextServer.JustificationFlag)3,
        TextServer.Direction direction = 0, TextServer.Orientation orientation = 0, float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawString(font, pos, text, alignment, width, fontSize, modulate,
            justificationFlags, direction, orientation, oversampling);
    }

    public void DrawMultilineString(Font font, Vector2 pos, string text, HorizontalAlignment alignment = 0,
        float width = -1, int fontSize = 16, int maxLines = -1, Color? modulate = null,
        TextServer.LineBreakFlag brkFlags = (TextServer.LineBreakFlag)3,
        TextServer.JustificationFlag justificationFlags = (TextServer.JustificationFlag)3,
        TextServer.Direction direction = 0, TextServer.Orientation orientation = 0, float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawMultilineString(font, pos, text, alignment, width, fontSize, maxLines, modulate,
            brkFlags, justificationFlags, direction, orientation, oversampling);
    }

    public void DrawStringOutline(Font font, Vector2 pos, string text, HorizontalAlignment alignment = 0,
        float width = -1, int fontSize = 16, int size = 1, Color? modulate = null,
        TextServer.JustificationFlag justificationFlags = (TextServer.JustificationFlag)3,
        TextServer.Direction direction = 0, TextServer.Orientation orientation = 0, float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawStringOutline(font, pos, text, alignment, width, fontSize, size, modulate,
            justificationFlags, direction, orientation, oversampling);
    }

    public void DrawMultilineStringOutline(Font font, Vector2 pos, string text, HorizontalAlignment alignment = 0,
        float width = -1, int fontSize = 16, int maxLines = -1, int size = 1, Color? modulate = null,
        TextServer.LineBreakFlag brkFlags = (TextServer.LineBreakFlag)3,
        TextServer.JustificationFlag justificationFlags = (TextServer.JustificationFlag)3,
        TextServer.Direction direction = 0, TextServer.Orientation orientation = 0, float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawMultilineStringOutline(font, pos, text, alignment, width, fontSize, maxLines, size,
            modulate, brkFlags, justificationFlags, direction, orientation, oversampling);
    }

    public void DrawChar(Font font, Vector2 pos, string @char, int fontSize = 16, Color? modulate = null,
        float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawChar(font, pos, @char, fontSize, modulate, oversampling);
    }

    public void DrawCharOutline(Font font, Vector2 pos, string @char, int fontSize = 16, int size = -1,
        Color? modulate = null, float oversampling = 0.0f)
    {
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawCharOutline(font, pos, @char, fontSize, size, modulate, oversampling);
    }

    public void DrawMesh(Mesh mesh, Texture2D texture, Transform2D? transform = null, Color? modulate = null)
    {
        transform ??= Transform2D.Identity;
        modulate ??= new Color(1.0f, 1.0f, 1.0f);
        Object.DrawMesh(mesh, texture, transform, modulate);
    }

    public void DrawMultimesh(MultiMesh multimesh, Texture2D texture)
    {
        Object.DrawMultimesh(multimesh, texture);
    }

    public void DrawSetTransform(Vector2 position, float rotation = 0.0f, Vector2? scale = null)
    {
        scale ??= new Vector2(1.0f, 1.0f);
        Object.DrawSetTransform(position, rotation, scale);
    }

    public void DrawSetTransformMatrix(Transform2D xform)
    {
        Object.DrawSetTransformMatrix(xform);
    }

    public void DrawAnimationSlice(float animationLength, float sliceBegin, float sliceEnd, float offset = 0.0f)
    {
        Object.DrawAnimationSlice(animationLength, sliceBegin, sliceEnd, offset);
    }

    public void DrawEndAnimation()
    {
        Object.DrawEndAnimation();
    }

    public Transform2D GetTransform()
    {
        return Object.GetTransform();
    }

    public Transform2D GetGlobalTransform()
    {
        return Object.GetGlobalTransform();
    }

    public Transform2D GetGlobalTransformWithCanvas()
    {
        return Object.GetGlobalTransformWithCanvas();
    }

    public Transform2D GetViewportTransform()
    {
        return Object.GetViewportTransform();
    }

    public Rect2 GetViewportRect()
    {
        return Object.GetViewportRect();
    }

    public Transform2D GetCanvasTransform()
    {
        return Object.GetCanvasTransform();
    }

    public Transform2D GetScreenTransform()
    {
        return Object.GetScreenTransform();
    }

    public Vector2 GetLocalMousePosition()
    {
        return Object.GetLocalMousePosition();
    }

    public Vector2 GetGlobalMousePosition()
    {
        return Object.GetGlobalMousePosition();
    }

    public Rid GetCanvas()
    {
        return Object.GetCanvas();
    }

    public CanvasLayer GetCanvasLayerNode()
    {
        return Object.GetCanvasLayerNode();
    }

    // public World2D GetWorld2d()
    // {
    //     return Object.GetWorld2d();
    // }

    public void SetMaterial(Material material)
    {
        Object.SetMaterial(material);
    }

    public Material GetMaterial()
    {
        return Object.GetMaterial();
    }

    public void SetInstanceShaderParameter(StringName name, Variant value)
    {
        Object.SetInstanceShaderParameter(name, value);
    }

    public Variant GetInstanceShaderParameter(StringName name)
    {
        return Object.GetInstanceShaderParameter(name);
    }

    public void SetUseParentMaterial(bool enable)
    {
        Object.SetUseParentMaterial(enable);
    }

    public bool GetUseParentMaterial()
    {
        return Object.GetUseParentMaterial();
    }

    public void SetNotifyLocalTransform(bool enable)
    {
        Object.SetNotifyLocalTransform(enable);
    }

    public bool IsLocalTransformNotificationEnabled()
    {
        return Object.IsLocalTransformNotificationEnabled();
    }

    public void SetNotifyTransform(bool enable)
    {
        Object.SetNotifyTransform(enable);
    }

    public bool IsTransformNotificationEnabled()
    {
        return Object.IsTransformNotificationEnabled();
    }

    public void ForceUpdateTransform()
    {
        Object.ForceUpdateTransform();
    }

    public Vector2 MakeCanvasPositionLocal(Vector2 viewportPoint)
    {
        return Object.MakeCanvasPositionLocal(viewportPoint);
    }

    public InputEvent MakeInputLocal(InputEvent @event)
    {
        return Object.MakeInputLocal(@event);
    }

    public void SetVisibilityLayer(uint layer)
    {
        Object.SetVisibilityLayer(layer);
    }

    public uint GetVisibilityLayer()
    {
        return Object.GetVisibilityLayer();
    }

    public void SetVisibilityLayerBit(uint layer, bool enabled)
    {
        Object.SetVisibilityLayerBit(layer, enabled);
    }

    public bool GetVisibilityLayerBit(uint layer)
    {
        return Object.GetVisibilityLayerBit(layer);
    }

    public void SetTextureFilter(CanvasItem.TextureFilterEnum mode)
    {
        Object.SetTextureFilter(mode);
    }

    public CanvasItem.TextureFilterEnum GetTextureFilter()
    {
        return Object.GetTextureFilter();
    }

    public void SetTextureRepeat(CanvasItem.TextureRepeatEnum mode)
    {
        Object.SetTextureRepeat(mode);
    }

    public CanvasItem.TextureRepeatEnum GetTextureRepeat()
    {
        return Object.GetTextureRepeat();
    }

    public void SetClipChildrenMode(CanvasItem.ClipChildrenMode mode)
    {
        Object.SetClipChildrenMode(mode);
    }

    public CanvasItem.ClipChildrenMode GetClipChildrenMode()
    {
        return Object.GetClipChildrenMode();
    }

    public static void PrintOrphanNodes()
    {
        Node.PrintOrphanNodes();
    }

    public static Array<int> GetOrphanNodeIds()
    {
        return Node.GetOrphanNodeIds();
    }

    public void AddSibling(Node sibling, bool forceReadableName = false)
    {
        Object.AddSibling(sibling, forceReadableName);
    }

    public void SetName(StringName name)
    {
        Object.SetName(name);
    }

    public StringName GetName()
    {
        return Object.GetName();
    }

    public void AddChild(Node node, bool forceReadableName = false, Node.InternalMode @internal = 0)
    {
        Object.AddChild(node, forceReadableName, @internal);
    }

    public void RemoveChild(Node node)
    {
        Object.RemoveChild(node);
    }

    public void Reparent(Node newParent, bool keepGlobalTransform = true)
    {
        Object.Reparent(newParent, keepGlobalTransform);
    }

    public int GetChildCount(bool includeInternal = false)
    {
        return Object.GetChildCount(includeInternal);
    }

    public Array<Node> GetChildren(bool includeInternal = false)
    {
        return Object.GetChildren(includeInternal);
    }

    public Node GetChild(int idx, bool includeInternal = false)
    {
        return Object.GetChild(idx, includeInternal);
    }

    public bool HasNode(NodePath path)
    {
        return Object.HasNode(path);
    }

    public Node GetNode(NodePath path)
    {
        return Object.GetNode(path);
    }

    public Node GetNodeOrNull(NodePath path)
    {
        return Object.GetNodeOrNull(path);
    }

    public Node GetParent()
    {
        return Object.GetParent();
    }

    public Node FindChild(string pattern, bool recursive = true, bool owned = true)
    {
        return Object.FindChild(pattern, recursive, owned);
    }

    public Array<Node> FindChildren(string pattern, string type = "", bool recursive = true,
        bool owned = true)
    {
        return Object.FindChildren(pattern, type, recursive, owned);
    }

    public Node FindParent(string pattern)
    {
        return Object.FindParent(pattern);
    }

    public bool HasNodeAndResource(NodePath path)
    {
        return Object.HasNodeAndResource(path);
    }

    public Godot.Collections.Array GetNodeAndResource(NodePath path)
    {
        return Object.GetNodeAndResource(path);
    }

    public bool IsInsideTree()
    {
        return Object.IsInsideTree();
    }

    public bool IsPartOfEditedScene()
    {
        return Object.IsPartOfEditedScene();
    }

    public bool IsAncestorOf(Node node)
    {
        return Object.IsAncestorOf(node);
    }

    public bool IsGreaterThan(Node node)
    {
        return Object.IsGreaterThan(node);
    }

    public NodePath GetPath()
    {
        return Object.GetPath();
    }

    public NodePath GetPathTo(Node node, bool useUniquePath = false)
    {
        return Object.GetPathTo(node, useUniquePath);
    }

    public void AddToGroup(StringName group, bool persistent = false)
    {
        Object.AddToGroup(group, persistent);
    }

    public void RemoveFromGroup(StringName group)
    {
        Object.RemoveFromGroup(group);
    }

    public bool IsInGroup(StringName group)
    {
        return Object.IsInGroup(group);
    }

    public void MoveChild(Node childNode, int toIndex)
    {
        Object.MoveChild(childNode, toIndex);
    }

    public Array<StringName> GetGroups()
    {
        return Object.GetGroups();
    }

    public void SetOwner(Node owner)
    {
        Object.SetOwner(owner);
    }

    public Node GetOwner()
    {
        return Object.GetOwner();
    }

    public int GetIndex(bool includeInternal = false)
    {
        return Object.GetIndex(includeInternal);
    }

    public void PrintTree()
    {
        Object.PrintTree();
    }

    public void PrintTreePretty()
    {
        Object.PrintTreePretty();
    }

    public string GetTreeString()
    {
        return Object.GetTreeString();
    }

    public string GetTreeStringPretty()
    {
        return Object.GetTreeStringPretty();
    }

    public void SetSceneFilePath(string sceneFilePath)
    {
        Object.SetSceneFilePath(sceneFilePath);
    }

    public string GetSceneFilePath()
    {
        return Object.GetSceneFilePath();
    }

    public void PropagateNotification(int what)
    {
        Object.PropagateNotification(what);
    }

    public void PropagateCall(StringName method, Godot.Collections.Array? args = null, bool parentFirst = false)
    {
        args ??= new Godot.Collections.Array();
        Object.PropagateCall(method, args, parentFirst);
    }

    public void SetPhysicsProcess(bool enable)
    {
        Object.SetPhysicsProcess(enable);
    }

    public double GetPhysicsProcessDeltaTime()
    {
        return Object.GetPhysicsProcessDeltaTime();
    }

    public bool IsPhysicsProcessing()
    {
        return Object.IsPhysicsProcessing();
    }

    public double GetProcessDeltaTime()
    {
        return Object.GetProcessDeltaTime();
    }

    public void SetProcess(bool enable)
    {
        Object.SetProcess(enable);
    }

    public void SetProcessPriority(int priority)
    {
        Object.SetProcessPriority(priority);
    }

    public int GetProcessPriority()
    {
        return Object.GetProcessPriority();
    }

    public void SetPhysicsProcessPriority(int priority)
    {
        Object.SetPhysicsProcessPriority(priority);
    }

    public int GetPhysicsProcessPriority()
    {
        return Object.GetPhysicsProcessPriority();
    }

    public bool IsProcessing()
    {
        return Object.IsProcessing();
    }

    public void SetProcessInput(bool enable)
    {
        Object.SetProcessInput(enable);
    }

    public bool IsProcessingInput()
    {
        return Object.IsProcessingInput();
    }

    public void SetProcessShortcutInput(bool enable)
    {
        Object.SetProcessShortcutInput(enable);
    }

    public bool IsProcessingShortcutInput()
    {
        return Object.IsProcessingShortcutInput();
    }

    public void SetProcessUnhandledInput(bool enable)
    {
        Object.SetProcessUnhandledInput(enable);
    }

    public bool IsProcessingUnhandledInput()
    {
        return Object.IsProcessingUnhandledInput();
    }

    public void SetProcessUnhandledKeyInput(bool enable)
    {
        Object.SetProcessUnhandledKeyInput(enable);
    }

    public bool IsProcessingUnhandledKeyInput()
    {
        return Object.IsProcessingUnhandledKeyInput();
    }

    public void SetProcessMode(Node.ProcessModeEnum mode)
    {
        Object.SetProcessMode(mode);
    }

    public Node.ProcessModeEnum GetProcessMode()
    {
        return Object.GetProcessMode();
    }

    public bool CanProcess()
    {
        return Object.CanProcess();
    }

    public void SetProcessThreadGroup(Node.ProcessThreadGroupEnum mode)
    {
        Object.SetProcessThreadGroup(mode);
    }

    public Node.ProcessThreadGroupEnum GetProcessThreadGroup()
    {
        return Object.GetProcessThreadGroup();
    }

    public void SetProcessThreadMessages(Node.ProcessThreadMessagesEnum flags)
    {
        Object.SetProcessThreadMessages(flags);
    }

    public Node.ProcessThreadMessagesEnum GetProcessThreadMessages()
    {
        return Object.GetProcessThreadMessages();
    }

    public void SetProcessThreadGroupOrder(int order)
    {
        Object.SetProcessThreadGroupOrder(order);
    }

    public int GetProcessThreadGroupOrder()
    {
        return Object.GetProcessThreadGroupOrder();
    }

    public void QueueAccessibilityUpdate()
    {
        Object.QueueAccessibilityUpdate();
    }

    public Rid GetAccessibilityElement()
    {
        return Object.GetAccessibilityElement();
    }

    public void SetDisplayFolded(bool fold)
    {
        Object.SetDisplayFolded(fold);
    }

    public bool IsDisplayedFolded()
    {
        return Object.IsDisplayedFolded();
    }

    public void SetProcessInternal(bool enable)
    {
        Object.SetProcessInternal(enable);
    }

    public bool IsProcessingInternal()
    {
        return Object.IsProcessingInternal();
    }

    public void SetPhysicsProcessInternal(bool enable)
    {
        Object.SetPhysicsProcessInternal(enable);
    }

    public bool IsPhysicsProcessingInternal()
    {
        return Object.IsPhysicsProcessingInternal();
    }

    public void SetPhysicsInterpolationMode(Node.PhysicsInterpolationModeEnum mode)
    {
        Object.SetPhysicsInterpolationMode(mode);
    }

    public Node.PhysicsInterpolationModeEnum GetPhysicsInterpolationMode()
    {
        return Object.GetPhysicsInterpolationMode();
    }

    public bool IsPhysicsInterpolated()
    {
        return Object.IsPhysicsInterpolated();
    }

    public bool IsPhysicsInterpolatedAndEnabled()
    {
        return Object.IsPhysicsInterpolatedAndEnabled();
    }

    public void ResetPhysicsInterpolation()
    {
        Object.ResetPhysicsInterpolation();
    }

    public void SetAutoTranslateMode(Node.AutoTranslateModeEnum mode)
    {
        Object.SetAutoTranslateMode(mode);
    }

    public Node.AutoTranslateModeEnum GetAutoTranslateMode()
    {
        return Object.GetAutoTranslateMode();
    }

    public bool CanAutoTranslate()
    {
        return Object.CanAutoTranslate();
    }

    public void SetTranslationDomainInherited()
    {
        Object.SetTranslationDomainInherited();
    }

    public Window GetWindow()
    {
        return Object.GetWindow();
    }

    public Window GetLastExclusiveWindow()
    {
        return Object.GetLastExclusiveWindow();
    }

    public SceneTree GetTree()
    {
        return Object.GetTree();
    }

    public Tween CreateTween()
    {
        return Object.CreateTween();
    }

    public Node Duplicate(int flags = 15)
    {
        return Object.Duplicate(flags);
    }

    public void ReplaceBy(Node node, bool keepGroups = false)
    {
        Object.ReplaceBy(node, keepGroups);
    }

    public void SetSceneInstanceLoadPlaceholder(bool loadPlaceholder)
    {
        Object.SetSceneInstanceLoadPlaceholder(loadPlaceholder);
    }

    public bool GetSceneInstanceLoadPlaceholder()
    {
        return Object.GetSceneInstanceLoadPlaceholder();
    }

    public void SetEditableInstance(Node node, bool isEditable)
    {
        Object.SetEditableInstance(node, isEditable);
    }

    public bool IsEditableInstance(Node node)
    {
        return Object.IsEditableInstance(node);
    }

    public Viewport GetViewport()
    {
        return Object.GetViewport();
    }

    public void QueueFree()
    {
        Object.QueueFree();
    }

    public void RequestReady()
    {
        Object.RequestReady();
    }

    public bool IsNodeReady()
    {
        return Object.IsNodeReady();
    }

    public void SetMultiplayerAuthority(int id, bool recursive = true)
    {
        Object.SetMultiplayerAuthority(id, recursive);
    }

    public int GetMultiplayerAuthority()
    {
        return Object.GetMultiplayerAuthority();
    }

    public bool IsMultiplayerAuthority()
    {
        return Object.IsMultiplayerAuthority();
    }

    public MultiplayerApi GetMultiplayer()
    {
        return Object.GetMultiplayer();
    }

    public void RpcConfig(StringName method, Variant config)
    {
        Object.RpcConfig(method, config);
    }

    public Variant GetNodeRpcConfig()
    {
        return Object.GetNodeRpcConfig();
    }

    public void SetEditorDescription(string editorDescription)
    {
        Object.SetEditorDescription(editorDescription);
    }

    public string GetEditorDescription()
    {
        return Object.GetEditorDescription();
    }

    public void SetUniqueNameInOwner(bool enable)
    {
        Object.SetUniqueNameInOwner(enable);
    }

    public bool IsUniqueNameInOwner()
    {
        return Object.IsUniqueNameInOwner();
    }

    public string Atr(string message, StringName? context = null)
    {
        context ??= "";
        return Object.Atr(message, context);
    }

    public string AtrN(string message, StringName pluralMessage, int n, StringName? context = null)
    {
        context ??= "";
        return Object.AtrN(message, pluralMessage, n, context);
    }

    public Error Rpc(StringName method, params Variant[] varargs)
    {
        return Object.Rpc(method, varargs);
    }

    public Error RpcId(int peerId, StringName method, params Variant[] varargs)
    {
        return Object.RpcId(peerId, method, varargs);
    }

    public void UpdateConfigurationWarnings()
    {
        Object.UpdateConfigurationWarnings();
    }

    public Variant CallDeferredThreadGroup(StringName method, params Variant[] varargs)
    {
        return Object.CallDeferredThreadGroup(method, varargs);
    }

    public void SetDeferredThreadGroup(StringName property, Variant value)
    {
        Object.SetDeferredThreadGroup(property, value);
    }

    public void NotifyDeferredThreadGroup(int what)
    {
        Object.NotifyDeferredThreadGroup(what);
    }

    public Variant CallThreadSafe(StringName method, params Variant[] varargs)
    {
        return Object.CallThreadSafe(method, varargs);
    }

    public void SetThreadSafe(StringName property, Variant value)
    {
        Object.SetThreadSafe(property, value);
    }

    public void NotifyThreadSafe(int what)
    {
        Object.NotifyThreadSafe(what);
    }

    public void Free()
    {
        Object.Free();
    }

    public string GetClass()
    {
        return Object.GetClass();
    }

    public bool IsClass(string @class)
    {
        return Object.IsClass(@class);
    }

    public void Set(StringName property, Variant value)
    {
        Object.Set(property, value);
    }

    public Variant Get(StringName property)
    {
        return Object.Get(property);
    }

    public void SetIndexed(NodePath propertyPath, Variant value)
    {
        Object.SetIndexed(propertyPath, value);
    }

    public Variant GetIndexed(NodePath propertyPath)
    {
        return Object.GetIndexed(propertyPath);
    }

    public Array<Dictionary> GetPropertyList()
    {
        return Object.GetPropertyList();
    }

    public Array<Dictionary> GetMethodList()
    {
        return Object.GetMethodList();
    }

    public bool PropertyCanRevert(StringName property)
    {
        return Object.PropertyCanRevert(property);
    }

    public Variant PropertyGetRevert(StringName property)
    {
        return Object.PropertyGetRevert(property);
    }

    public void Notification(int what, bool reversed = false)
    {
        Object.Notification(what, reversed);
    }

    public override string ToString()
    {
        return Object.ToString();
    }

    public ulong GetInstanceId()
    {
        return Object.GetInstanceId();
    }

    public void SetScript(Variant script)
    {
        Object.SetScript(script);
    }

    public Variant GetScript()
    {
        return Object.GetScript();
    }

    public void SetMeta(StringName name, Variant value)
    {
        Object.SetMeta(name, value);
    }

    public void RemoveMeta(StringName name)
    {
        Object.RemoveMeta(name);
    }

    public Variant GetMeta(StringName name, Variant @default = default)
    {
        return Object.GetMeta(name, @default);
    }

    public bool HasMeta(StringName name)
    {
        return Object.HasMeta(name);
    }

    public Array<StringName> GetMetaList()
    {
        return Object.GetMetaList();
    }

    public void AddUserSignal(string signal, Godot.Collections.Array? arguments = null)
    {
        arguments ??= new Godot.Collections.Array();
        Object.AddUserSignal(signal, arguments);
    }

    public bool HasUserSignal(StringName signal)
    {
        return Object.HasUserSignal(signal);
    }

    public void RemoveUserSignal(StringName signal)
    {
        Object.RemoveUserSignal(signal);
    }

    public Error EmitSignal(StringName signal, params Variant[] varargs)
    {
        return Object.EmitSignal(signal, varargs);
    }

    public Variant Call(StringName method, params Variant[] varargs)
    {
        return Object.Call(method, varargs);
    }

    public Variant CallDeferred(StringName method, params Variant[] varargs)
    {
        return Object.CallDeferred(method, varargs);
    }

    public void SetDeferred(StringName property, Variant value)
    {
        Object.SetDeferred(property, value);
    }

    public Variant Callv(StringName method, Godot.Collections.Array argArray)
    {
        return Object.Callv(method, argArray);
    }

    public bool HasMethod(StringName method)
    {
        return Object.HasMethod(method);
    }

    public int GetMethodArgumentCount(StringName method)
    {
        return Object.GetMethodArgumentCount(method);
    }

    public bool HasSignal(StringName signal)
    {
        return Object.HasSignal(signal);
    }

    public Array<Dictionary> GetSignalList()
    {
        return Object.GetSignalList();
    }

    public Array<Dictionary> GetSignalConnectionList(StringName signal)
    {
        return Object.GetSignalConnectionList(signal);
    }

    public Array<Dictionary> GetIncomingConnections()
    {
        return Object.GetIncomingConnections();
    }

    public Error Connect(StringName signal, Callable callable, uint flags = 0)
    {
        return Object.Connect(signal, callable, flags);
    }

    public void Disconnect(StringName signal, Callable callable)
    {
        Object.Disconnect(signal, callable);
    }

    public bool IsConnected(StringName signal, Callable callable)
    {
        return Object.IsConnected(signal, callable);
    }

    public bool HasConnections(StringName signal)
    {
        return Object.HasConnections(signal);
    }

    public void SetBlockSignals(bool enable)
    {
        Object.SetBlockSignals(enable);
    }

    public bool IsBlockingSignals()
    {
        return Object.IsBlockingSignals();
    }

    public void NotifyPropertyListChanged()
    {
        Object.NotifyPropertyListChanged();
    }

    public void SetMessageTranslation(bool enable)
    {
        Object.SetMessageTranslation(enable);
    }

    public bool CanTranslateMessages()
    {
        return Object.CanTranslateMessages();
    }

    public string Tr(StringName message, StringName? context = null)
    {
        context ??= "";
        return Object.Tr(message, context);
    }

    public string TrN(StringName message, StringName pluralMessage, int n, StringName? context = null)
    {
        context ??= "";
        return Object.TrN(message, pluralMessage, n, context);
    }

    public StringName GetTranslationDomain()
    {
        return Object.GetTranslationDomain();
    }

    public void SetTranslationDomain(StringName domain)
    {
        Object.SetTranslationDomain(domain);
    }

    public bool IsQueuedForDeletion()
    {
        return Object.IsQueuedForDeletion();
    }

    public void CancelFree()
    {
        Object.CancelFree();
    }

    #endregion

    #region Inherited Signals

    public event Action<int> BreakpointToggled
    {
        add => Connect(CodeEdit.SignalName.BreakpointToggled, Callable.From(value));
        remove => Disconnect(CodeEdit.SignalName.BreakpointToggled, Callable.From(value));
    }

    public event Action CodeCompletionRequested
    {
        add => Connect(CodeEdit.SignalName.CodeCompletionRequested, Callable.From(value));
        remove => Disconnect(CodeEdit.SignalName.CodeCompletionRequested, Callable.From(value));
    }

    public event Action<string, int, int> SymbolLookup
    {
        add => Connect(CodeEdit.SignalName.SymbolLookup, Callable.From(value));
        remove => Disconnect(CodeEdit.SignalName.SymbolLookup, Callable.From(value));
    }

    public event Action<string> SymbolValidate
    {
        add => Connect(CodeEdit.SignalName.SymbolValidate, Callable.From(value));
        remove => Disconnect(CodeEdit.SignalName.SymbolValidate, Callable.From(value));
    }

    public event Action<string, int, int> SymbolHovered
    {
        add => Connect(CodeEdit.SignalName.SymbolHovered, Callable.From(value));
        remove => Disconnect(CodeEdit.SignalName.SymbolHovered, Callable.From(value));
    }

    public event Action TextSet
    {
        add => Connect(TextEdit.SignalName.TextSet, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.TextSet, Callable.From(value));
    }

    public event Action TextChanged
    {
        add => Connect(TextEdit.SignalName.TextChanged, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.TextChanged, Callable.From(value));
    }

    public event Action<int, int> LinesEditedFrom
    {
        add => Connect(TextEdit.SignalName.LinesEditedFrom, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.LinesEditedFrom, Callable.From(value));
    }

    public event Action CaretChanged
    {
        add => Connect(TextEdit.SignalName.CaretChanged, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.CaretChanged, Callable.From(value));
    }

    public event Action<int, int> GutterClicked
    {
        add => Connect(TextEdit.SignalName.GutterClicked, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.GutterClicked, Callable.From(value));
    }

    public event Action GutterAdded
    {
        add => Connect(TextEdit.SignalName.GutterAdded, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.GutterAdded, Callable.From(value));
    }

    public event Action GutterRemoved
    {
        add => Connect(TextEdit.SignalName.GutterRemoved, Callable.From(value));
        remove => Disconnect(TextEdit.SignalName.GutterRemoved, Callable.From(value));
    }

    public event Action Resized
    {
        add => Connect(Control.SignalName.Resized, Callable.From(value));
        remove => Disconnect(Control.SignalName.Resized, Callable.From(value));
    }

    public event Action<InputEvent> GuiInput
    {
        add => Connect(Control.SignalName.GuiInput, Callable.From(value));
        remove => Disconnect(Control.SignalName.GuiInput, Callable.From(value));
    }

    public event Action MouseEntered
    {
        add => Connect(Control.SignalName.MouseEntered, Callable.From(value));
        remove => Disconnect(Control.SignalName.MouseEntered, Callable.From(value));
    }

    public event Action MouseExited
    {
        add => Connect(Control.SignalName.MouseExited, Callable.From(value));
        remove => Disconnect(Control.SignalName.MouseExited, Callable.From(value));
    }

    public event Action FocusEntered
    {
        add => Connect(Control.SignalName.FocusEntered, Callable.From(value));
        remove => Disconnect(Control.SignalName.FocusEntered, Callable.From(value));
    }

    public event Action FocusExited
    {
        add => Connect(Control.SignalName.FocusExited, Callable.From(value));
        remove => Disconnect(Control.SignalName.FocusExited, Callable.From(value));
    }

    public event Action SizeFlagsChanged
    {
        add => Connect(Control.SignalName.SizeFlagsChanged, Callable.From(value));
        remove => Disconnect(Control.SignalName.SizeFlagsChanged, Callable.From(value));
    }

    public event Action MinimumSizeChanged
    {
        add => Connect(Control.SignalName.MinimumSizeChanged, Callable.From(value));
        remove => Disconnect(Control.SignalName.MinimumSizeChanged, Callable.From(value));
    }

    public event Action ThemeChanged
    {
        add => Connect(Control.SignalName.ThemeChanged, Callable.From(value));
        remove => Disconnect(Control.SignalName.ThemeChanged, Callable.From(value));
    }

    public event Action Draw
    {
        add => Connect(CanvasItem.SignalName.Draw, Callable.From(value));
        remove => Disconnect(CanvasItem.SignalName.Draw, Callable.From(value));
    }

    public event Action VisibilityChanged
    {
        add => Connect(CanvasItem.SignalName.VisibilityChanged, Callable.From(value));
        remove => Disconnect(CanvasItem.SignalName.VisibilityChanged, Callable.From(value));
    }

    public event Action Hidden
    {
        add => Connect(CanvasItem.SignalName.Hidden, Callable.From(value));
        remove => Disconnect(CanvasItem.SignalName.Hidden, Callable.From(value));
    }

    public event Action ItemRectChanged
    {
        add => Connect(CanvasItem.SignalName.ItemRectChanged, Callable.From(value));
        remove => Disconnect(CanvasItem.SignalName.ItemRectChanged, Callable.From(value));
    }

    public event Action Ready
    {
        add => Connect(Node.SignalName.Ready, Callable.From(value));
        remove => Disconnect(Node.SignalName.Ready, Callable.From(value));
    }

    public event Action Renamed
    {
        add => Connect(Node.SignalName.Renamed, Callable.From(value));
        remove => Disconnect(Node.SignalName.Renamed, Callable.From(value));
    }

    public event Action TreeEntered
    {
        add => Connect(Node.SignalName.TreeEntered, Callable.From(value));
        remove => Disconnect(Node.SignalName.TreeEntered, Callable.From(value));
    }

    public event Action TreeExiting
    {
        add => Connect(Node.SignalName.TreeExiting, Callable.From(value));
        remove => Disconnect(Node.SignalName.TreeExiting, Callable.From(value));
    }

    public event Action TreeExited
    {
        add => Connect(Node.SignalName.TreeExited, Callable.From(value));
        remove => Disconnect(Node.SignalName.TreeExited, Callable.From(value));
    }

    public event Action<Node> ChildEnteredTree
    {
        add => Connect(Node.SignalName.ChildEnteredTree, Callable.From(value));
        remove => Disconnect(Node.SignalName.ChildEnteredTree, Callable.From(value));
    }

    public event Action<Node> ChildExitingTree
    {
        add => Connect(Node.SignalName.ChildExitingTree, Callable.From(value));
        remove => Disconnect(Node.SignalName.ChildExitingTree, Callable.From(value));
    }

    public event Action ChildOrderChanged
    {
        add => Connect(Node.SignalName.ChildOrderChanged, Callable.From(value));
        remove => Disconnect(Node.SignalName.ChildOrderChanged, Callable.From(value));
    }

    public event Action<Node> ReplacingBy
    {
        add => Connect(Node.SignalName.ReplacingBy, Callable.From(value));
        remove => Disconnect(Node.SignalName.ReplacingBy, Callable.From(value));
    }

    public event Action<Node> EditorDescriptionChanged
    {
        add => Connect(Node.SignalName.EditorDescriptionChanged, Callable.From(value));
        remove => Disconnect(Node.SignalName.EditorDescriptionChanged, Callable.From(value));
    }

    public event Action EditorStateChanged
    {
        add => Connect(Node.SignalName.EditorStateChanged, Callable.From(value));
        remove => Disconnect(Node.SignalName.EditorStateChanged, Callable.From(value));
    }

    public event Action ScriptChanged
    {
        add => Connect(GodotObject.SignalName.ScriptChanged, Callable.From(value));
        remove => Disconnect(GodotObject.SignalName.ScriptChanged, Callable.From(value));
    }

    public event Action PropertyListChanged
    {
        add => Connect(GodotObject.SignalName.PropertyListChanged, Callable.From(value));
        remove => Disconnect(GodotObject.SignalName.PropertyListChanged, Callable.From(value));
    }

    #endregion
}