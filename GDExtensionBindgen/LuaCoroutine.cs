// This code was automatically generated by GDExtension C# Bindgen

using System;
using Godot;
using Array = Godot.Collections.Array;

namespace GDExtensionBindgen;

public class LuaCoroutine : LuaThread
{
	public LuaCoroutine() : base(NativeName)
	{
	}
	protected LuaCoroutine(StringName @class) : base(@class)
	{
	}
	protected LuaCoroutine(Variant variant) : base(variant)
	{
	}
	protected LuaCoroutine(RefCounted @object) : base(@object)
	{
	}

	public static implicit operator RefCounted(LuaCoroutine self) => self?.Object;
	public static implicit operator Variant(LuaCoroutine self) => self?.Object;
	public static explicit operator LuaCoroutine(Variant variant) => variant.AsGodotObject() != null ? new LuaCoroutine(variant) : null;

	public new class PropertyName : LuaThread.PropertyName
	{

	}

	public new class MethodName : LuaThread.MethodName
	{
		public static readonly StringName Resumev = "resumev";
		public static readonly StringName Resume = "resume";
		public static readonly StringName Create = "create";
	}

	public new class SignalName : LuaThread.SignalName
	{
		public static readonly StringName Completed = "completed";
		public static readonly StringName Failed = "failed";
	}

	private static readonly StringName NativeName = "LuaCoroutine";

	#region Methods

	public Variant Resumev(Array arguments)
	{
		return Object.Call(MethodName.Resumev, arguments);
	}

	public Variant Resume(params Variant[] varargs)
	{
		return Object.Call(MethodName.Resume, varargs);
	}

	public static LuaCoroutine Create(LuaFunction function)
	{
		return (LuaCoroutine)ClassDB.ClassCallStatic(NativeName, MethodName.Create, function);
	}

	#endregion

	#region Signals

	public event Action<Variant> Completed
	{
		add => Connect(SignalName.Completed, Callable.From(value));
		remove => Disconnect(SignalName.Completed, Callable.From(value));
	}

	public event Action<LuaError> Failed
	{
		add => Connect(SignalName.Failed, Callable.From(value));
		remove => Disconnect(SignalName.Failed, Callable.From(value));
	}

	#endregion
}
