// ReSharper disable CommentTypo
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable IdentifierTypo
// ReSharper disable UnusedType.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable EventNeverSubscribedTo.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable StringLiteralTypo
// ReSharper disable MemberHidesStaticFromOuterClass
// This code was automatically generated by GDExtension C# Bindgen

using System;
using System.Collections.Generic;
using Godot;

namespace GUITest.scripts.Proxy;

public class LuaThread : LuaObject
{
    public LuaThread() : base(NativeName)
    {
    }

    protected LuaThread(StringName @class) : base(@class)
    {
    }

    protected LuaThread(Variant variant) : base(variant)
    {
    }

    protected LuaThread(RefCounted @object) : base(@object)
    {
    }

    public static implicit operator RefCounted(LuaThread self) => self.Object;
    public static implicit operator Variant(LuaThread self) => self.Object;
    public static explicit operator LuaThread(Variant variant) => new(variant.AsGodotObject());

    public new class PropertyName : LuaObject.PropertyName
    {
        public static readonly StringName Status = "status";
    }

    public new class MethodName : LuaObject.MethodName
    {
        public static readonly StringName GetStatus = "get_status";
        public static readonly StringName IsMainThread = "is_main_thread";
        public static readonly StringName SetHook = "set_hook";
        public static readonly StringName GetHook = "get_hook";
        public static readonly StringName GetHookMask = "get_hook_mask";
        public static readonly StringName GetHookCount = "get_hook_count";
        public static readonly StringName GetStackLevelInfo = "get_stack_level_info";
        public static readonly StringName GetStackInfo = "get_stack_info";
        public static readonly StringName GetTraceback = "get_traceback";
    }

    public new class SignalName : LuaObject.SignalName
    {
    }

    private static readonly StringName NativeName = "LuaThread";

    #region Enums

    public enum StatusEnum : long
    {
        Ok = 0L,
        Yield = 1L,
        Errrun = 2L,
        Errsyntax = 3L,
        Errmem = 4L,
        Errerr = 5L,
        Dead = -1L,
    }

    [Flags]
    public enum HookMask : long
    {
        Call = 1L,
        Return = 2L,
        Line = 4L,
        Count = 8L,
    }

    public enum HookEvent : long
    {
        Call = 0L,
        Return = 1L,
        Line = 2L,
        Count = 3L,
        TailCall = 4L,
        TailReturn = 4L,
    }

    public enum HookResult : long
    {
        Ok = 0L,
        Yield = -1L,
    }

    #endregion

    #region Properties

    public StatusEnum Status => (StatusEnum)(int)Object.Get(PropertyName.Status);

    #endregion

    #region Methods

    public StatusEnum GetStatus()
    {
        return (StatusEnum)(int)Object.Call(MethodName.GetStatus);
    }

    public bool IsMainThread()
    {
        return (bool)Object.Call(MethodName.IsMainThread);
    }

    public void SetHook(Variant hook, HookMask mask, int count = 0)
    {
        Object.Call(MethodName.SetHook, hook, (int)mask, count);
    }

    public Variant GetHook()
    {
        return Object.Call(MethodName.GetHook);
    }

    public HookMask GetHookMask()
    {
        return (HookMask)(int)Object.Call(MethodName.GetHookMask);
    }

    public int GetHookCount()
    {
        return (int)Object.Call(MethodName.GetHookCount);
    }

    public LuaDebug GetStackLevelInfo(int level)
    {
        return (LuaDebug)Object.Call(MethodName.GetStackLevelInfo, level);
    }

    public LuaDebug[] GetStackInfo()
    {
        var output = Object.Call(MethodName.GetStackInfo);
        var ret = new List<LuaDebug>();

        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (var obj in output.AsGodotArray())
            ret.Add((LuaDebug)obj);

        return ret.ToArray();
    }

    public string GetTraceback(string message = "", int level = 0)
    {
        return (string)Object.Call(MethodName.GetTraceback, message, level);
    }

    #endregion
}